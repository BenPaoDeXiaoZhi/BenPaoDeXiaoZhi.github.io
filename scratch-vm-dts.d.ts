// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../events
//   ../@turbowarp/jszip
//   ../format-message
//   ../immutable
//   ../node:events
//   ../jszip
import R=require("scratch-vm-dts/engine/runtime")
declare type Runtime = import('scratch-vm-dts/engine/runtime')
declare var Runtime:typeof R;
declare module 'scratch-vm-dts' {
    export = VirtualMachine;
    import VirtualMachine = require("scratch-vm-dts/virtual-machine");
}

declare module 'scratch-vm-dts/virtual-machine' {
    export = VirtualMachine;
    import Target = require('scratch-vm-dts/engine/target');
    import Sequencer = require('scratch-vm-dts/engine/sequencer');
    namespace Blockly{
            class Event{
            }
    }
    class StreamHelper{}
    class ImportedProject{}
    class Gandi{}
    class int extends Number{}
    class Block{}
    class bool extends Boolean{}
    class Costume{}
    class ImportedExtensionsInfo{}
    class AudioEngine{}
    class RenderWebGL{}
    class ScratchStorage{}
    /**
        * Handles connections between blocks, stage, and extensions.
        * @constructor
        */
    class VirtualMachine extends EventEmitter<[never]> {
            static get FIND_PYTHON_CODE(): string;
            constructor();
            /**
                * VM runtime, to store blocks, I/O devices, sprites/targets, etc.
                * @type {!Runtime}
                */
            runtime: Runtime;
            /**
                * The "currently editing"/selected target ID for the VM.
                * Block events from any Blockly workspace are routed to this target.
                * @type {Target}
                */
            editingTarget: Target;
            /**
                * This variable indicates whether asynchronous loading of project resource files is supported
                */
            asyncLoadingProjectAssetsSupported: boolean;
            /**
                * The currently dragging target, for redirecting IO data.
                * @type {Target}
                */
            _dragTarget: Target;
            /**
                * The current project resource loading progress.
                * @type {Progress}
                */
            _assetsLoadProgress: Progress;
            extensionManager: ExtensionManager;
            securityManager: import("scratch-vm-dts/extension-support/tw-security-manager");
            /**
                * Handle a Blockly event for the current editing target.
                * @param {!Blockly.Event} e Any Blockly event.
                */
            blockListener(e: Blockly.Event): void;
            /**
                * Handle a Blockly event for the current editing target.
                * @param {!Blockly.Event} e Any Blockly event.
                */
            frameListener(e: Blockly.Event): void;
            /**
                * Handle a Blockly event for the flyout.
                * @param {!Blockly.Event} e Any Blockly event.
                */
            flyoutBlockListener(e: Blockly.Event): void;
            /**
                * Handle a Blockly event for the flyout to be passed to the monitor container.
                * @param {!Blockly.Event} e Any Blockly event.
                */
            monitorBlockListener(e: Blockly.Event): void;
            /**
                * Handle a Blockly event for the variable map.
                * @param {!Blockly.Event} e Any Blockly event.
                */
            variableListener(e: Blockly.Event): void;
            /**
                * Export some internal classes for extensions.
                */
            exports: {
                    Sprite: typeof Sprite;
                    RenderedTarget: typeof RenderedTarget;
                    JSZip: JSZip;
                    i_will_not_ask_for_help_when_these_break: () => {
                            JSGenerator: typeof import("./compiler/jsgen.js");
                            IRGenerator: typeof import("./compiler/irgen.js").IRGenerator;
                            ScriptTreeGenerator: typeof import("./compiler/irgen.js").ScriptTreeGenerator;
                            Thread: typeof import("./engine/thread.js");
                            execute: (sequencer: Sequencer, thread: import("scratch-vm-dts/engine/thread.js")) => void;
                    };
            };
            _projectProcessingUniqueId: number;
            /**
                * Start running the VM - do this before anything else.
                */
            start(): void;
            /**
                * @deprecated Used by old versions of TurboWarp. Superceded by upstream's quit()
                */
            stop(): void;
            /**
                * Quit the VM, clearing any handles which might keep the process alive.
                * Do not use the runtime after calling this method. This method is meant for test shutdown.
                */
            quit(): void;
            /**
                * "Green flag" handler - start all threads starting with a green flag.
                */
            greenFlag(): void;
            /**
                * Set whether the VM is in "turbo mode."
                * When true, loops don't yield to redraw.
                * @param {boolean} turboModeOn Whether turbo mode should be set.
                */
            setTurboMode(turboModeOn: boolean): void;
            /**
                * Set whether the VM is in 2.0 "compatibility mode."
                * When true, ticks go at 2.0 speed (30 TPS).
                * @param {boolean} compatibilityModeOn Whether compatibility mode is set.
                */
            setCompatibilityMode(compatibilityModeOn: boolean): void;
            setFramerate(framerate: any): void;
            setInterpolation(interpolationEnabled: any): void;
            setRuntimeOptions(runtimeOptions: any): void;
            /**
                * ccw: Set ccw API to runtime support ccw block extensions
                * @param {*} ccwAPI ccw API
                */
            setCCWAPI(ccwAPI: any): void;
            setCompilerOptions(compilerOptions: any): void;
            setIsPlayerOnly(isPlayerOnly: any): void;
            setStageSize(width: any, height: any): void;
            setInEditor(inEditor: any): void;
            convertToPackagedRuntime(): void;
            addAddonBlock(options: any): void;
            getAddonBlock(procedureCode: any): any;
            storeProjectOptions(): void;
            enableDebug(): string;
            handleExtensionButtonPress(button: any): void;
            /**
                * Stop all threads and running activities.
                */
            stopAll(): void;
            disposeAll(): void;
            /**
                * Clear out current running project data.
                */
            clear(): void;
            /**
                * Get data for playground. Data comes back in an emitted event.
                */
            getPlaygroundData(): void;
            /**
                * Post I/O data to the virtual devices.
                * @param {?string} device Name of virtual I/O device.
                * @param {object} data Any data object to post to the I/O device.
                */
            postIOData(device: string | null, data: object): void;
            setVideoProvider(videoProvider: any): void;
            setCloudProvider(cloudProvider: any): void;
            /**
                * Tell the specified extension to scan for a peripheral.
                * @param {string} extensionId - the id of the extension.
                */
            scanForPeripheral(extensionId: string): void;
            /**
                * Connect to the extension's specified peripheral.
                * @param {string} extensionId - the id of the extension.
                * @param {number} peripheralId - the id of the peripheral.
                */
            connectPeripheral(extensionId: string, peripheralId: number): void;
            /**
                * Disconnect from the extension's connected peripheral.
                * @param {string} extensionId - the id of the extension.
                */
            disconnectPeripheral(extensionId: string): void;
            /**
                * Returns whether the extension has a currently connected peripheral.
                * @param {string} extensionId - the id of the extension.
                * @return {boolean} - whether the extension has a connected peripheral.
                */
            getPeripheralIsConnected(extensionId: string): boolean;
            /**
                * Load a Scratch project from a .sb, .sb2, .sb3 or json string.
                * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.
                * @param {?function} jsonFormatter A function to format the project json.
                * @return {!Promise} Promise that resolves after targets are installed.
                */
            loadProject(input: string | object, jsonFormatter: Function | null, options: any): Promise<any>;
            /**
                * Load a project from the Scratch web site, by ID.
                * @param {string} id - the ID of the project to download, as a string.
                */
            downloadProjectId(id: string): void;
            /**
                * @returns {JSZip} JSZip zip object representing the sb3.
                */
            _saveProjectZip(): JSZip;
            /**
                * @param {JSZip.OutputType} [type] JSZip output type. Defaults to 'blob' for Scratch compatibility.
                * @returns {Promise<unknown>} Compressed sb3 file in a type determined by the type argument.
                */
            saveProjectSb3(type?: JSZip.OutputType): Promise<unknown>;
            /**
                * @param {JSZip.OutputType} [type] JSZip output type. Defaults to 'arraybuffer'.
                * @returns {StreamHelper} JSZip StreamHelper object generating the compressed sb3.
                * See: https://stuk.github.io/jszip/documentation/api_streamhelper.html
                */
            saveProjectSb3Stream(type?: JSZip.OutputType): StreamHelper;
            /**
                * tw: Serialize the project into a map of files without actually zipping the project.
                * The buffers returned are the exact same ones used internally, not copies. Avoid directly
                * manipulating them (except project.json, which is created by this function).
                * @returns {Record<string, Uint8Array>} Map of file name to the raw data for that file.
                */
            saveProjectSb3DontZip(): Record<string, Uint8Array>;
            /**
                * Serialize project.
                * @param {object} whetherSerialize
                * @param {boolean} whetherSerialize.isSerializeSounds whether to serialize sound
                * @param {boolean} whetherSerialize.isSerializeCostumes whether to serialize costumes
                * @param {boolean} whetherSerialize.isSerializeJson whether to serialize json
                * @returns {Object} Serialized state of the runtime.
                */
            serializeProject({ isSerializeSounds, isSerializeCostumes, isSerializeJson }?: {
                    isSerializeSounds: boolean;
                    isSerializeCostumes: boolean;
                    isSerializeJson: boolean;
            }): Object;
            /**
                * @type {Array<object>} Array of all assets currently in the runtime
                */
            get assets(): Array<object>;
            generateUid(): string;
            getSb3Utils(): {
                    serialize: (runtime: Runtime, targetId?: string | undefined, { allowOptimization, saveVarId }?: {
                            allowOptimization?: boolean | undefined;
                            saveVarId?: boolean | undefined;
                    }) => object;
                    deserialize: (json: object, runtime: Runtime, zip: JSZip, isSingleSprite: boolean) => Promise<ImportedProject>;
                    deserializeBlocks: (blocks: object) => object;
                    deserializeInputs: (inputs: object, parentId: string, blocks: object) => object;
                    deserializeFields: (fields: object) => object;
                    serializeBlocks: (blocks: object, saveVarId: boolean | null) => any[];
                    serializeTarget: (target: object, extensions: Set<any>, saveVarId: boolean | null) => object;
                    serializeMonitors: (monitors: any, runtime: any, extensions: any) => any;
                    deserializeMonitor: (monitorData: any, runtime: any, targets: any, extensions: any) => void;
                    serializeSound: (sound: object) => object;
                    deserializeSound: (sound: object, runtime: Runtime, zip: JSZip, assetFileName: string) => Promise<any>;
                    serializeComments: (comments: any) => any;
                    serializeVariables: (variables: object) => object;
                    getExtensionIdForOpcode: (opcode: string) => string | null;
                    deserializeInputDesc: (inputDescOrId: string | Array<any>, parentId: string, isShadow: boolean, blocks: object, blockId: any) => object;
                    serializePrimitiveBlock: (block: object, saveVarId: boolean | null) => Array<any>;
                    primitiveOpcodeInfoMap: {
                            math_number: (string | number)[];
                            math_positive_number: (string | number)[];
                            math_whole_number: (string | number)[];
                            math_integer: (string | number)[];
                            math_angle: (string | number)[];
                            colour_picker: (string | number)[];
                            text: (string | number)[];
                            event_broadcast_menu: (string | number)[];
                            data_variable: (string | number)[];
                            data_listcontents: (string | number)[];
                    };
                    deserializeStandaloneBlocks: (blocks: unknown) => {
                            blocks: Block[];
                            extensionURLs: Map<string, string>;
                    };
                    serializeStandaloneBlocks: (blocks: Block[], runtime: Runtime) => object;
            };
            createGandiAssetFile(name: any, assetType: any, data?: string): void;
            getGandiAssetsList(typesArray: any): any;
            getGandiAssetContent(fileName: any): any;
            getGandiAssetsFileList(type: any): any;
            getGandiAssetFile(fileName: any): any;
            getGandiAssetById(id: any): any;
            getGandiAssetIndexAndFileById(id: any): {
                    file: any;
                    index: number;
            };
            /**
                * @param {string} targetId Optional ID of target to export
                * @returns {Array<{fileName: string; fileContent: Uint8Array;}} list of file descs
                */
            serializeAssets(targetId: string): Array<{
                    fileName: string;
                    fileContent: Uint8Array;
            }>;
            _addFileDescsToZip(fileDescs: any, zip: any): void;
            /**
                * Exports a sprite in the sprite3 format.
                * @param {string} targetId ID of the target to export
                * @param {string=} optZipType Optional type that the resulting
                * zip should be outputted in. Options are: base64, binarystring,
                * array, uint8array, arraybuffer, blob, or nodebuffer. Defaults to
                * blob if argument not provided.
                * See https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html#type-option
                * for more information about these options.
                * @return {object} A generated zip of the sprite and its assets in the format
                * specified by optZipType or blob by default.
                */
            exportSprite(targetId: string, optZipType?: string | undefined): object;
            /**
                * Export project or sprite as a Scratch 3.0 JSON representation.
                * @param {string=} optTargetId - Optional id of a sprite to serialize
                * @param {*} serializationOptions Options to pass to the serializer
                * @return {string} Serialized state of the runtime.
                */
            toJSON(optTargetId?: string | undefined, serializationOptions: any): string;
            /**
                * Serialize a sprite in the sprite3 format.
                * @param {string} targetId ID of the target to export
                * @param {?Boolean} saveVarId Whether to save the variable ID or not
                * @returns {Object} Serialized state of the runtime.
                */
            serializeSprite(targetId: string, saveVarId: boolean | null): Object;
            /**
                * Serialize sprite assets for gui
                * @param {string} targetId ID of the target to export
                * @returns {Object} sound & costume & spriteJson result of serialize
                */
            serializeSpriteAssets(targetId: string): Object;
            /**
                * Load a project from a Scratch JSON representation.
                * @param {string} json JSON string representing a project.
                * @returns {Promise} Promise that resolves after the project has loaded
                */
            fromJSON(json: string): Promise<any>;
            /**
                * Load a project from a Scratch JSON representation.
                * @param {string} projectJSON JSON string representing a project.
                * @param {?JSZip} zip Optional zipped project containing assets to be loaded.
                * @param {number} _projectProcessingUniqueId 加载project的Id
                * @returns {Promise} Promise that resolves after the project has loaded
                */
            deserializeProject(projectJSON: string, zip: JSZip | null, _projectProcessingUniqueId: number, options: any): Promise<any>;
            /**
                * Install `deserialize` results: zero or more targets after the extensions (if any) used by those targets.
                * @param {Array.<Target>} targets - the targets to be installed
                * @param {ImportedExtensionsInfo} extensions - metadata about extensions used by these targets
                * @param {Gandi} gandiObject - the gandi Object to be merged
                * @param {boolean} wholeProject - set to true if installing a whole project, as opposed to a single sprite.
                * @param {number} _projectProcessingUniqueId 加载project的Id
                * @param {boolean} isRemoteOperation - set to true if this is a remote operation
                * @returns {Promise<{addedTargets:Target[], addedGandiObject:Gandi}>} resolved once targets and Gandi object have been installed
                */
            installTargets(targets: Array<Target>, extensions: ImportedExtensionsInfo, gandiObject: Gandi, wholeProject: boolean, _projectProcessingUniqueId: number, isRemoteOperation: boolean, options: any): Promise<{
                    addedTargets: Target[];
                    addedGandiObject: Gandi;
            }>;
            /**
                * Add a sprite, this could be .sprite2 or .sprite3. Unpack and validate
                * such a file first.
                * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.
                * @param {?string} isRemoteOperation - set to true if this is a remote operation
                * @return {!Promise} Promise that resolves after targets are installed.
                */
            addSprite(input: string | object, isRemoteOperation: string | null): Promise<any>;
            /**
                * Add a single sprite from the "Sprite2" (i.e., SB2 sprite) format.
                * @param {object} sprite Object representing 2.0 sprite to be added.
                * @param {?ArrayBuffer} zip Optional zip of assets being referenced by json
                * @param {?boolean} isRemoteOperation Whether to change editing target
                * @returns {Promise} Promise that resolves after the sprite is added
                */
            _addSprite2(sprite: object, zip: ArrayBuffer | null, isRemoteOperation: boolean | null): Promise<any>;
            /**
                * Add a single sb3 sprite.
                * @param {object} sprite Object rperesenting 3.0 sprite to be added.
                * @param {?ArrayBuffer} zip Optional zip of assets being referenced by target json
                * @param {?boolean} isRemoteOperation Whether to change editing target
                * @returns {Promise} Promise that resolves after the sprite is added
                */
            _addSprite3(sprite: object, zip: ArrayBuffer | null, isRemoteOperation: boolean | null): Promise<any>;
            /**
                * Add a costume to the current editing target.
                * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
                * @param {!object} costumeObject Object representing the costume.
                * @param {string} target - the target to add to.
                * @param {?int} index Index at which to add costume
                * @returns {?Promise} - a promise that resolves when the costume has been added
                */
            addCostumeFromRemote(md5ext: string, costumeObject: object, target: string, index: int | null): Promise<any> | null;
            /**
                * Add a costume to the current editing target.
                * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
                * @param {!object} costumeObject Object representing the costume.
                * @property {int} skinId - the ID of the costume's render skin, once installed.
                * @property {number} rotationCenterX - the X component of the costume's origin.
                * @property {number} rotationCenterY - the Y component of the costume's origin.
                * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
                * @param {string} optTargetId - the id of the target to add to, if not the editing target.
                * @param {string} optVersion - if this is 2, load costume as sb2, otherwise load costume as sb3.
                * @param {boolean} isRemoteOperation Whether this is a remote operation.
                * @returns {?Promise} - a promise that resolves when the costume has been added
                */
            addCostume(md5ext: string, costumeObject: object, optTargetId: string, optVersion: string, isRemoteOperation: boolean): Promise<any> | null;
            /**
                * Add a costume loaded from the library to the current editing target.
                * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
                * @param {!object} costumeObject Object representing the costume.
                * @property {int} skinId - the ID of the costume's render skin, once installed.
                * @property {number} rotationCenterX - the X component of the costume's origin.
                * @property {number} rotationCenterY - the Y component of the costume's origin.
                * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
                * @returns {?Promise} - a promise that resolves when the costume has been added
                */
            addCostumeFromLibrary(md5ext: string, costumeObject: object): Promise<any> | null;
            /**
                * Duplicate the costume at the given index. Add it at that index + 1.
                * @param {!int} costumeIndex Index of costume to duplicate
                * @returns {?Promise} - a promise that resolves when the costume has been decoded and added
                */
            duplicateCostume(costumeIndex: int): Promise<any> | null;
            /**
                * Duplicate the sound at the given index. Add it at that index + 1.
                * @param {!int} soundIndex Index of sound to duplicate
                * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
                */
            duplicateSound(soundIndex: int): Promise<any> | null;
            /**
                * Rename a costume on the current editing target.
                * @param {int} costumeIndex - the index of the costume to be renamed.
                * @param {string} newName - the desired new name of the costume (will be modified if already in use).
                */
            renameCostume(costumeIndex: int, newName: string): void;
            /**
                * Delete a costume from the current editing target.
                * @param {int} costumeIndex - the index of the costume to be removed.
                * @return {?function} A function to restore the deleted costume, or null,
                * if no costume was deleted.
                */
            deleteCostume(costumeIndex: int): Function | null;
            /**
                * Add a sound to the current editing target.
                * @param {!object} soundObject Object representing the sound.
                * @param {string} optTargetId - the id of the target to add to, if not the editing target.
                * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
                */
            addSound(soundObject: object, optTargetId: string): Promise<any> | null;
            /**
                * Rename a sound on the current editing target.
                * @param {int} soundIndex - the index of the sound to be renamed.
                * @param {string} newName - the desired new name of the sound (will be modified if already in use).
                */
            renameSound(soundIndex: int, newName: string): void;
            /**
                * Get a sound buffer from the audio engine.
                * @param {int} soundIndex - the index of the sound to be got.
                * @return {AudioBuffer} the sound's audio buffer.
                */
            getSoundBuffer(soundIndex: int): AudioBuffer;
            /**
                * Sets a configuration property in the Gandi runtime.
                *
                * @param {string} key - The key of the configuration property to set.
                * @param value - The value to set for the configuration property.
                */
            setGandiConfigProperty(key: string, value: any): void;
            /**
                * Gets a configuration property from the Gandi runtime.
                *
                * @param {string}  key - The key of the configuration property to retrieve.
                * @returns The value of the configuration property.
                */
            getGandiConfigProperty(key: string): any;
            getMonitoredKeys(): any[];
            /**
                * Updates global procedure call mutations in the project.
                *
                * @param {string} oldProccode - The old procedure code to be replaced.
                * @param {string} newMutationText - The new mutation text to replace the old mutation.
                * @returns {void}
                */
            updateGlobalProcedureCallMutation(oldProccode: string, newMutationText: string): void;
            /**
                * Update a sound buffer.
                * @param {int} soundIndex - the index of the sound to be updated.
                * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.
                * @param {ArrayBuffer} soundEncoding - the new (wav) encoded sound to be stored
                * @param {string} targetId - the id of the target to be updated.
                */
            updateSoundBuffer(soundIndex: int, newBuffer: AudioBuffer, soundEncoding: ArrayBuffer, targetId: string): void;
            /**
                * Delete a sound from the current editing target.
                * @param {int} soundIndex - the index of the sound to be removed.
                * @return {?Function} A function to restore the sound that was deleted,
                * or null, if no sound was deleted.
                */
            deleteSound(soundIndex: int): Function | null;
            /**
                * Get a string representation of the image from storage.
                * @param {int} costumeIndex - the index of the costume to be got.
                * @return {string} the costume's SVG string if it's SVG,
                *     a dataURI if it's a PNG or JPG, or null if it couldn't be found or decoded.
                */
            getCostume(costumeIndex: int): string;
            updateCostumeById(target: any, id: any, newCostume: any): void;
            updateSoundById(target: any, id: any, newSound: any): void;
            /**
                * TW: Get the raw binary data to use when exporting a costume to the user's local file system.
                * @param {Costume} costumeObject scratch-vm costume object
                * @returns {Uint8Array}
                */
            getExportedCostume(costumeObject: Costume): Uint8Array;
            /**
                * TW: Get a base64 string to use when exporting a costume to the user's local file system.
                * @param {Costume} costumeObject scratch-vm costume object
                * @returns {string} base64 string. Not a data: URI.
                */
            getExportedCostumeBase64(costumeObject: Costume): string;
            /**
                * Update a costume with the given bitmap
                * @param {!int} costumeIndex - the index of the costume to be updated.
                * @param {!ImageData} bitmap - new bitmap for the renderer.
                * @param {!number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
                * @param {!number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
                * @param {!number} bitmapResolution 1 for bitmaps that have 1 pixel per unit of stage,
                *     2 for double-resolution bitmaps
                * @param {string} targetId ID of a target.
                */
            updateBitmap(costumeIndex: int, bitmap: ImageData, rotationCenterX: number, rotationCenterY: number, bitmapResolution: number): void;
            _updateBitmap(costume: any, bitmap: any, rotationCenterX: any, rotationCenterY: any, bitmapResolution: any): void;
            /**
                * Update a costume with the given SVG
                * @param {int} costumeIndex - the index of the costume to be updated.
                * @param {string} svg - new SVG for the renderer.
                * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
                * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
                * @param {string} targetId ID of a target.
                */
            updateSvg(costumeIndex: int, svg: string, rotationCenterX: number, rotationCenterY: number, targetId: string): void;
            _updateSvg(costume: any, svg: any, rotationCenterX: any, rotationCenterY: any, targetId: any): void;
            /**
                * Update a Gandi asset with the value
                * @param {string} assetMd5 - the md5 of the asset to be updated.
                * @param {string} newValue - new Value for the asset.
                */
            updateGandiAssetData(fileName: any, newValue: string): void;
            updateGandiAssetFromRemote(id: any, newAsset: any): void;
            addGandiAssetFromRemote(id: any, newAsset: any): void;
            deleteGandiAssetFromRemote(id: any): void;
            /**
                * rename a Gandi asset
                * @param {string} id - The id of the asset to rename.
                * @param {string} newName - new name for the asset.
                */
            renameGandiAssetById(id: string, newName: string): any;
            /**
                * Delete a sprite and all its clones.
                * @param {string} fileName name of a asset.
                */
            deleteGandiAsset(fileName: string): void;
            /**
                * Delete a file from the Gandi assets.
                * @param {string} id The id of the asset to delete.
                */
            deleteGandiAssetById(id: string): void;
            /**
                * Add a backdrop to the stage.
                * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.
                * @param {!object} backdropObject Object representing the backdrop.
                * @property {int} skinId - the ID of the backdrop's render skin, once installed.
                * @property {number} rotationCenterX - the X component of the backdrop's origin.
                * @property {number} rotationCenterY - the Y component of the backdrop's origin.
                * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.
                * @returns {?Promise} - a promise that resolves when the backdrop has been added
                */
            addBackdrop(md5ext: string, backdropObject: object): Promise<any> | null;
            /**
                * Rename a sprite.
                * @param {string} targetId ID of a target whose sprite to rename.
                * @param {string} newName New name of the sprite.
                * @param {boolean} [sendNameChangedEvent = true] whether to send an event when the sprite name changes.
                */
            renameSprite(targetId: string, newName: string, sendNameChangedEvent?: boolean): void;
            /**
                * Delete a sprite and all its clones.
                * @param {string} targetId ID of a target whose sprite to delete.
                * @param {boolean} isRemoteOperation Whether this is a remote operation.
                * @return {Function} Returns a function to restore the sprite that was deleted
                */
            deleteSprite(targetId: string, isRemoteOperation: boolean): Function;
            /**
                * Duplicate a sprite.
                * @param {string} targetId ID of a target whose sprite to duplicate.
                * @returns {Promise} Promise that resolves when duplicated target has
                *     been added to the runtime.
                */
            duplicateSprite(targetId: string): Promise<any>;
            /**
                * Set the audio engine for the VM/runtime
                * @param {!AudioEngine} audioEngine The audio engine to attach
                */
            attachAudioEngine(audioEngine: AudioEngine): void;
            /**
                * Set the renderer for the VM/runtime
                * @param {!RenderWebGL} renderer The renderer to attach
                */
            attachRenderer(renderer: RenderWebGL): void;
            /**
                * @returns {RenderWebGL} The renderer attached to the vm
                */
            get renderer(): RenderWebGL;
            attachV2SVGAdapter(): void;
            /**
                * Set the bitmap adapter for the VM/runtime, which converts scratch 2
                * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)
                * @param {!function} bitmapAdapter The adapter to attach
                */
            attachV2BitmapAdapter(bitmapAdapter: Function): void;
            /**
                * Set the storage module for the VM/runtime
                * @param {!ScratchStorage} storage The storage module to attach
                */
            attachStorage(storage: ScratchStorage): void;
            /**
                * set the current locale and builtin messages for the VM
                * @param {!string} locale       current locale
                * @param {!object} messages     builtin messages map for current locale
                * @returns {Promise} Promise that resolves when all the blocks have been
                *     updated for a new locale (or empty if locale hasn't changed.)
                */
            setLocale(locale: string, messages: object): Promise<any>;
            /**
                * get the current locale for the VM
                * @returns {string} the current locale in the VM
                */
            getLocale(): string;
            /**
                * Delete all of the flyout blocks.
                */
            clearFlyoutBlocks(): void;
            /**
                * Set an editing target. An editor UI can use this function to switch
                * between editing different targets, sprites, etc.
                * After switching the editing target, the VM may emit updates
                * to the list of targets and any attached workspace blocks
                * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).
                * @param {string} targetId Id of target to set as editing.
                */
            setEditingTarget(targetId: string): void;
            /**
                * @param {Block[]} blockObjects
                * @returns {object}
                */
            exportStandaloneBlocks(blockObjects: Block[]): object;
            /**
                * Called when blocks are dragged from one sprite to another. Adds the blocks to the
                * workspace of the given target.
                * @param {!Array<object>} blocks Blocks to add.
                * @param {!string} targetId Id of target to add blocks to.
                * @param {?string} optFromTargetId Optional target id indicating that blocks are being
                * shared from that target. This is needed for resolving any potential variable conflicts.
                * @return {!Promise} Promise that resolves when the extensions and blocks have been added.
                */
            shareBlocksToTarget(blocks: Array<object>, targetId: string, optFromTargetId: string | null): Promise<any>;
            /**
                * Called when frame are dragged from one sprite to another. Adds the frame to the
                * workspace of the given target.
                * @param {!Array<object>} frame Frame to add.
                * @param {!string} targetId Id of target to add frame to.
                * @param {?string} optFromTargetId Optional target id indicating that frame are being
                * shared from that target. This is needed for resolving any potential variable conflicts.
                * @return {!Promise} Promise that resolves when the extensions and frame have been added.
                */
            shareFrameToTarget(frame: Array<object>, targetId: string, optFromTargetId: string | null): Promise<any>;
            /**
                * Called when costumes are dragged from editing target to another target.
                * Sets the newly added costume as the current costume.
                * @param {!number} costumeIndex Index of the costume of the editing target to share.
                * @param {!string} targetId Id of target to add the costume.
                * @return {Promise} Promise that resolves when the new costume has been loaded.
                */
            shareCostumeToTarget(costumeIndex: number, targetId: string): Promise<any>;
            /**
                * Called when sounds are dragged from editing target to another target.
                * @param {!number} soundIndex Index of the sound of the editing target to share.
                * @param {!string} targetId Id of target to add the sound.
                * @return {Promise} Promise that resolves when the new sound has been loaded.
                */
            shareSoundToTarget(soundIndex: number, targetId: string): Promise<any>;
            /**
                * Repopulate the workspace with the blocks of the current editingTarget. This
                * allows us to get around bugs like gui#413.
                */
            refreshWorkspace(): void;
            /**
                * Emit metadata about available targets.
                * An editor UI could use this to display a list of targets and show
                * the currently editing one.
                * @param {boolean} triggerProjectChange If true, also emit a project changed event.
                * Disabled selectively by updates that don't affect project serialization.
                * Defaults to true.
                */
            emitTargetsUpdate(triggerProjectChange: boolean | undefined, updatedTargets: any): void;
            /**
                * Emit an Blockly/scratch-blocks compatible XML representation
                * of the current editing target's blocks.
                */
            emitWorkspaceUpdate(): void;
            /**
                * Emit metadata about Gandi assets file.
                * An editor UI could use this to display a list of files and show
                * the currently editing one.
                * @param {{data:object, type: 'add'|'update'|'delete', isFromRemote:bool}} action If true, also emit a project changed event.
                * Defaults to true.
                */
            emitGandiAssetsUpdate({ data, type }: {
                    data: object;
                    type: "add" | "update" | "delete";
                    isFromRemote: bool;
            }): void;
            /**
                * Get a target id for a drawable id. Useful for interacting with the renderer
                * @param {number} drawableId The drawable id to request the target id for
                * @returns {?string} The target id, if found. Will also be null if the target found is the stage.
                */
            getTargetIdForDrawableId(drawableId: number): string | null;
            /**
                * CCW: Get all global procedures and pass to target
                * @returns {Array} Array of XML strings
                */
            getWorkspaceGlobalProcedures(): any[];
            /**
                * Reorder target by index. Return whether a change was made.
                * @param {!string} targetIndex Index of the target.
                * @param {!number} newIndex index that the target should be moved to.
                * @param {!boolean} isRemoteOperation - set to true if this is a remote operation
                * @returns {boolean} Whether a target was reordered.
                */
            reorderTarget(targetIndex: string, newIndex: number, isRemoteOperation: boolean): boolean;
            /**
                * Reorder the costumes of a target if it exists. Return whether it succeeded.
                * @param {!string} targetId ID of the target which owns the costumes.
                * @param {!number} costumeIndex index of the costume to move.
                * @param {!number} newIndex index that the costume should be moved to.
                * @returns {boolean} Whether a costume was reordered.
                */
            reorderCostume(targetId: string, costumeIndex: number, newIndex: number): boolean;
            /**
                * Reorder the sounds of a target if it exists. Return whether it occured.
                * @param {!string} targetId ID of the target which owns the sounds.
                * @param {!number} soundIndex index of the sound to move.
                * @param {!number} newIndex index that the sound should be moved to.
                * @returns {boolean} Whether a sound was reordered.
                */
            reorderSound(targetId: string, soundIndex: number, newIndex: number): boolean;
            /**
                * Put a target into a "drag" state, during which its X/Y positions will be unaffected
                * by blocks.
                * @param {string} targetId The id for the target to put into a drag state
                */
            startDrag(targetId: string): void;
            /**
                * Remove a target from a drag state, so blocks may begin affecting X/Y position again
                * @param {string} targetId The id for the target to remove from the drag state
                */
            stopDrag(targetId: string): void;
            /**
                * Post/edit sprite info for the current editing target or the drag target.
                * @param {object} data An object with sprite info data to set.
                * @param {?string} targetId The id for the target to set info.
                */
            postSpriteInfo(data: object, targetId: string | null): void;
            /**
                * Set a target's variable's value. Return whether it succeeded.
                * @param {!string} targetId ID of the target which owns the variable.
                * @param {!string} variableId ID of the variable to set.
                * @param {!*} value The new value of that variable.
                * @returns {boolean} whether the target and variable were found and updated.
                */
            setVariableValue(targetId: string, variableId: string, value: any): boolean;
            /**
                * Get a target's variable's value. Return null if the target or variable does not exist.
                * @param {!string} targetId ID of the target which owns the variable.
                * @param {!string} variableId ID of the variable to set.
                * @returns {?*} The value of the variable, or null if it could not be looked up.
                */
            getVariableValue(targetId: string, variableId: string): any | null;
            /**
                * Allow VM consumer to configure the ScratchLink socket creator.
                * @param {Function} factory The custom ScratchLink socket factory.
                */
            configureScratchLinkSocketFactory(factory: Function): void;
            /**
                * Adapts a given XML element for blocks or frames.
                *
                * @param {Element} xml - The XML element to be adapted.
                * @returns {Array.<object> | null} A list of block or frame from the adapted XML.
                */
            xmlAdapter(xml: Element): Array<object> | null;
    }
    // namespace VirtualMachine {
    //         export { Progress };
    // }
    import EventEmitter = require("events");
    import Runtime = require("scratch-vm-dts/engine/runtime");
    import ExtensionManager = require("scratch-vm-dts/extension-support/extension-manager");
    import Sprite = require("scratch-vm-dts/sprites/sprite");
    import RenderedTarget = require("scratch-vm-dts/sprites/rendered-target");
    import JSZip = require("@turbowarp/jszip");
    import { number } from 'format-message';
    /**
        * - Information about the loading progress
        */
    type Progress = {
            /**
                * - The total number of loaded things
                */
            total: number;
            /**
                * - The number of loads completed
                */
            loaded: number;
    };
}

declare module 'scratch-vm-dts/engine/target' {
    export = Target;
    import Runtime from 'scratch-vm-dts/engine/runtime';
    class bool extends Boolean{
    }
    /**
        * @fileoverview
        * A Target is an abstract "code-running" object for the Scratch VM.
        * Examples include sprites/clones or potentially physical-world devices.
        */
    class Target extends EventEmitter<[never]> {
            /**
                * @param {Runtime} runtime Reference to the runtime.
                * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.
                * @param {?Frames} frames Shared frames object for all clones of sprite.
                * @param {?id} id Target id.
                * @constructor
                */
            constructor(runtime: Runtime, blocks: Blocks | null, frames: Frames | null, id: any | null);
            /**
                * Reference to the runtime.
                * @type {Runtime}
                */
            runtime: Runtime;
            /**
                * A unique ID for this target.
                * @type {string}
                */
            id: string;
            /**
                * Blocks run as code for this target.
                * @type {!Blocks}
                */
            blocks: Blocks;
            /**
                * Dictionary of variables and their values for this target.
                * Key is the variable id.
                * @type {Object.<string,*>}
                */
            variables: {
                    [x: string]: any;
            };
            /**
                * Dictionary of comments for this target.
                * Key is the comment id.
                * @type {Object.<string,*>}
                */
            comments: {
                    [x: string]: any;
            };
            /**
                * All frames that this target contains.
                * @type {!Frames}
                */
            frames: Frames;
            /**
                * Dictionary of custom state for this target.
                * This can be used to store target-specific custom state for blocks which need it.
                * TODO: do we want to persist this in SB3 files?
                * @type {Object.<string,*>}
                */
            _customState: {
                    [x: string]: any;
            };
            /**
                * Currently known values for edge-activated hats.
                * Keys are block ID for the hat; values are the currently known values.
                * @type {Object.<string, *>}
                */
            _edgeActivatedHatValues: {
                    [x: string]: any;
            };
            /**
                * Maps extension ID to a JSON-serializable value.
                * @type {Object.<string, object>}
                */
            extensionStorage: {
                    [x: string]: object;
            };
            /**
                * Called when the project receives a "green flag."
                * @abstract
                */
            onGreenFlag(): void;
            /**
                * Return a human-readable name for this target.
                * Target implementations should override this.
                * @abstract
                * @returns {string} Human-readable name for the target.
                */
            getName(): string;
            /**
                * Update an edge-activated hat block value.
                * @param {!string} blockId ID of hat to store value for.
                * @param {*} newValue Value to store for edge-activated hat.
                * @return {*} The old value for the edge-activated hat.
                */
            updateEdgeActivatedValue(blockId: string, newValue: any): any;
            hasEdgeActivatedValue(blockId: any): boolean;
            /**
                * Clear all edge-activaed hat values.
                */
            clearEdgeActivatedValues(): void;
            /**
                * Look up a variable object, first by id, and then by name if the id is not found.
                * Create a new variable if both lookups fail.
                * @param {string} id Id of the variable.
                * @param {string} name Name of the variable.
                * @return {!Variable} Variable object.
                */
            lookupOrCreateVariable(id: string, name: string): Variable;
            /**
                * Look up a broadcast message object with the given id and return it
                * if it exists.
                * @param {string} id Id of the variable.
                * @param {string} name Name of the variable.
                * @return {?Variable} Variable object.
                */
            lookupBroadcastMsg(id: string, name: string): Variable | null;
            /**
                * Look up a broadcast message with the given name and return the variable
                * if it exists. Does not create a new broadcast message variable if
                * it doesn't exist.
                * @param {string} name Name of the variable.
                * @return {?Variable} Variable object.
                */
            lookupBroadcastByInputValue(name: string): Variable | null;
            /**
                * Look up a variable object.
                * Search begins for local variables; then look for globals.
                * @param {string} id Id of the variable.
                * @param {string} name Name of the variable.
                * @return {!Variable} Variable object.
                */
            lookupVariableById(id: string): Variable;
            /**
                * Look up a variable object by its name and variable type.
                * Search begins with local variables; then global variables if a local one
                * was not found.
                * @param {string} name Name of the variable.
                * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
                * @param {?bool} skipStage Optional flag to skip checking the stage
                * @return {?Variable} Variable object if found, or null if not.
                */
            lookupVariableByNameAndType(name: string, type: string, skipStage: bool | null): Variable | null;
            /**
                * Look up if a variable is being used based on its name and type.
                * @param {string} name Name of the variable.
                * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
                * @return {?bool} True if found, or false if not.
                */
            findVariableUsage(name: string, type: string): bool | null;
            /**
             * Look up a list object for this target, and create it if one doesn't exist.
             * Search begins for local lists; then look for globals.
             * @param {!string} id Id of the list.
             * @param {!string} name Name of the list.
             * @return {!Variable} Variable object representing the found/created list.
                */
            lookupOrCreateList(id: string, name: string): Variable;
            /**
                * Creates a variable with the given id and name and adds it to the
                * dictionary of variables.
                * @param {string} id Id of variable
                * @param {string} name Name of variable.
                * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
                * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.
                * @param {boolean} isRemoteOperation - Set to true if this is a remote operation
                * Additional checks are made that the variable can be created as a cloud variable.
                */
            createVariable(id: string, name: string, type: string, isCloud: boolean, isRemoteOperation: boolean): void;
            /**
                * Creates a comment with the given properties.
                * @param {string} id Id of the comment.
                * @param {string} blockId Optional id of the block the comment is attached
                * to if it is a block comment.
                * @param {string} text The text the comment contains.
                * @param {number} x The x coordinate of the comment on the workspace.
                * @param {number} y The y coordinate of the comment on the workspace.
                * @param {number} width The width of the comment when it is full size
                * @param {number} height The height of the comment when it is full size
                * @param {boolean} minimized Whether the comment is minimized.
                * @param {boolean} isRemoteOperation - set to true if this is a remote operation
                */
            createComment(id: string, blockId: string, text: string, x: number, y: number, width: number, height: number, minimized: boolean, isRemoteOperation: boolean): void;
            /**
                * Creates a frame with the given properties.
                * @param {string} id Id of the frame.
                * @param {string} title The text the frame contains.
                * @param {number} x The x coordinate of the frame on the workspace.
                * @param {number} y The y coordinate of the frame on the workspace.
                * @param {number} width The width of the frame when it is full size
                * @param {number} height The height of the frame when it is full size
                */
            createFrame(frame: any): boolean;
            /**
                * Removes the frame with the given id from the dictionary of frames.
                * @param {string} id Id of frame to delete.
                */
            deleteFrame(id: string): void;
            /**
                * Renames the variable with the given id to newName.
                * @param {string} id Id of variable to rename.
                * @param {string} newName New name for the variable.
                */
            renameVariable(id: string, newName: string): void;
            /**
                * Removes the variable with the given id from the dictionary of variables.
                * @param {string} id Id of variable to delete.
                * @param {boolean} isRemoteOperation - set to true if this is a remote operation
                */
            deleteVariable(id: string, isRemoteOperation: boolean): void;
            /**
                * Remove this target's monitors from the runtime state and remove the
                * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).
                * NOTE: This does not delete any of the stage monitors like backdrop name.
                */
            deleteMonitors(): void;
            /**
                * Create a clone of the variable with the given id from the dictionary of
                * this target's variables.
                * @param {string} id Id of variable to duplicate.
                * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID
                * @param {!object} targetId ID of the target which owns the variable.
                * for the duplicate variable. This is necessary when cloning a sprite, for example.
                * @return {?Variable} The duplicated variable, or null if
                * the original variable was not found.
                */
            duplicateVariable(id: string, optKeepOriginalId?: boolean | undefined, targetId: string): Variable | null;
            /**
                * Duplicate the dictionary of this target's variables as part of duplicating.
                * this target or making a clone.
                * @param {!object} targetId ID of the target which owns this variables.
                * @param {object=} optBlocks Optional block container for the target being duplicated.
                * If provided, new variables will be generated with new UIDs and any variable references
                * in this blocks container will be updated to refer to the corresponding new IDs.
                * @return {object} The duplicated dictionary of variables
                */
            duplicateVariables(targetId: object, optBlocks?: object | undefined): object;
            /**
                * Post/edit sprite info.
                * @param {object} data An object with sprite info data to set.
                * @abstract
                */
            postSpriteInfo(): void;
            /**
                * Retrieve custom state associated with this target and the provided state ID.
                * @param {string} stateId - specify which piece of state to retrieve.
                * @returns {*} the associated state, if any was found.
                */
            getCustomState(stateId: string): any;
            /**
                * Store custom state associated with this target and the provided state ID.
                * @param {string} stateId - specify which piece of state to store on this target.
                * @param {*} newValue - the state value to store.
                */
            setCustomState(stateId: string, newValue: any): void;
            /**
                * Call to destroy a target.
                * @abstract
                */
            dispose(): void;
            /**
                * Get the names of all the variables of the given type that are in scope for this target.
                * For targets that are not the stage, this includes any target-specific
                * variables as well as any stage variables unless the skipStage flag is true.
                * For the stage, this is all stage variables.
                * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE
                * @param {?bool} skipStage Optional flag to skip the stage.
                * @return {Array<string>} A list of variable names
                */
            getAllVariableNamesInScopeByType(type: string, skipStage: bool | null): Array<string>;
            /**
                * Merge variable references with another variable.
                * @param {string} idToBeMerged ID of the variable whose references need to be updated
                * @param {string} idToMergeWith ID of the variable that the old references should be replaced with
                * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.
                * Defaults to all the blocks in this target.
                * @param {?string} optNewName New variable name to merge with. The old
                * variable name in the references being updated should be replaced with this new name.
                * If this parameter is not provided or is '', no name change occurs.
                */
            mergeVariables(idToBeMerged: string, idToMergeWith: string, optReferencesToUpdate: Array<Object> | null, optNewName: string | null): void;
            /**
                * Share a local variable (and given references for that variable) to the stage.
                * @param {string} varId The ID of the variable to share.
                * @param {Array<object>} varRefs The list of variable references being shared,
                * that reference the given variable ID. The names and IDs of these variable
                * references will be updated to refer to the new (or pre-existing) global variable.
                */
            shareLocalVariableToStage(varId: string, varRefs: Array<object>): void;
            /**
                * Share a local variable with a sprite, merging with one of the same name and
                * type if it already exists on the sprite, or create a new one.
                * @param {string} varId Id of the variable to share
                * @param {Target} sprite The sprite to share the variable with
                * @param {Array<object>} varRefs A list of all the variable references currently being shared.
                */
            shareLocalVariableToSprite(varId: string, sprite: Target, varRefs: Array<object>): void;
            /**
                * Given a list of variable referencing fields, shares those variables with
                * the target with the provided id, resolving any variable conflicts that arise
                * using the following rules:
                *
                * If this target is the stage, exit. There are no conflicts that arise
                * from sharing variables from the stage to another sprite. The variables
                * already exist globally, so no further action is needed.
                *
                * If a variable being referenced is a global variable, do nothing. The
                * global variable already exists so no further action is needed.
                *
                * If a variable being referenced is local, and
                * 1) The receiving target is a sprite:
                * create a new local variable or merge with an existing local variable
                * of the same name and type. Update all the referencing fields
                * for the original variable to reference the new variable.
                * 2) The receiving target is the stage:
                * Create a new global variable with a fresh name and update all the referencing
                * fields to reference the new variable.
                *
                * @param {Array<object>} blocks The blocks containing
                * potential conflicting references to variables.
                * @param {Target} receivingTarget The target receiving the variables
                */
            resolveVariableSharingConflictsWithTarget(blocks: Array<object>, receivingTarget: Target): void;
            resolveVariableSharingConflicts(blocks: any): void;
            /**
                * Fixes up variable references in this target avoiding conflicts with
                * pre-existing variables in the same scope.
                * This is used when uploading this target as a new sprite into an existing
                * project, where the new sprite may contain references
                * to variable names that already exist as global variables in the project
                * (and thus are in scope for variable references in the given sprite).
                *
                * If this target has a block that references an existing global variable and that
                * variable *does not* exist in this target (e.g. it was a global variable in the
                * project the sprite was originally exported from), merge the variables. This entails
                * fixing the variable references in this sprite to reference the id of the pre-existing global variable.
                *
                * If this target has a block that references an existing global variable and that
                * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),
                * then the local variable is renamed to distinguish itself from the pre-existing variable.
                * All blocks that reference the local variable will be updated to use the new name.
                */
            fixUpVariableReferences(): void;
            emitFast(...args: any[]): void;
    }
    import EventEmitter = require("events");
    import Blocks = require("scratch-vm-dts/engine/blocks");
    import Frames = require("scratch-vm-dts/engine/frame");
    import Variable = require("scratch-vm-dts/engine/variable");
}

declare module 'scratch-vm-dts/engine/sequencer' {
    export = Sequencer;
    import Runtime from 'scratch-vm-dts/engine/runtime';
    class Sequencer {
            /**
                * Time to run a warp-mode thread, in ms.
                * @type {number}
                */
            static get WARP_TIME(): number;
            constructor(runtime: any);
            /**
                * A utility timer for timing thread sequencing.
                * @type {!Timer}
                */
            timer: Timer;
            /**
                * Reference to the runtime owning this sequencer.
                * @type {!Runtime}
                */
            runtime: Runtime;
            activeThread: any;
            /**
                * Step through all threads in `this.runtime.threads`, running them in order.
                * @return {Array.<!Thread>} List of inactive threads after stepping.
                */
            stepThreads(): Array<Thread>;
            /**
                * Step the requested thread for as long as necessary.
                * @param {!Thread} thread Thread object to step.
                */
            stepThread(thread: Thread): void;
            /**
                * Step a thread into a block's branch.
                * @param {!Thread} thread Thread object to step to branch.
                * @param {number} branchNum Which branch to step to (i.e., 1, 2).
                * @param {boolean} isLoop Whether this block is a loop.
                */
            stepToBranch(thread: Thread, branchNum: number, isLoop: boolean): void;
            /**
                * Step a procedure.
                * @param {!Thread} thread Thread object to step to procedure.
                * @param {!string} procedureCode Procedure code of procedure to step to.
                * @param {!Target} Target CCW: for globalProcedure.
                */
            stepToProcedure(thread: Thread, procedureCode: string, globalTarget: any): void;
            /**
                * Retire a thread in the middle, without considering further blocks.
                * @param {!Thread} thread Thread object to retire.
                */
            retireThread(thread: Thread): void;
    }
    import Timer = require("scratch-vm-dts/util/timer");
    import Thread = require("scratch-vm-dts/engine/thread");
}

declare module 'scratch-vm-dts/engine/runtime' {
    export = Runtime;
    import Target from "scratch-vm-dts/engine/target";
    
    class ScratchLinkSocket{}
    class AudioEngine{}
    class RenderWebGL{}
    class ScratchStorage{}
    class MonitorRecord{}
    /**
        * Manages targets, scripts, and the sequencer.
        * @constructor
        */
    class Runtime extends EventEmitter<[never]> {
            /**
                * Width of the stage, in pixels.
                * @const {number}
                */
            static get STAGE_WIDTH(): number;
            /**
                * Height of the stage, in pixels.
                * @const {number}
                */
            static get STAGE_HEIGHT(): number;
            /**
                * Event name for glowing a script.
                * @const {string}
                */
            static get SCRIPT_GLOW_ON(): string;
            /**
                * Event name for unglowing a script.
                * @const {string}
                */
            static get SCRIPT_GLOW_OFF(): string;
            /**
                * Event name for glowing a block.
                * @const {string}
                */
            static get BLOCK_GLOW_ON(): string;
            /**
                * Event name for unglowing a block.
                * @const {string}
                */
            static get BLOCK_GLOW_OFF(): string;
            /**
                * Event name for a cloud data update
                * to this project.
                * @const {string}
                */
            static get HAS_CLOUD_DATA_UPDATE(): string;
            /**
                * Event name for turning on turbo mode.
                * @const {string}
                */
            static get TURBO_MODE_ON(): string;
            /**
                * Event name for turning off turbo mode.
                * @const {string}
                */
            static get TURBO_MODE_OFF(): string;
            /**
                * Event name for runtime options changing.
                * @const {string}
                */
            static get RUNTIME_OPTIONS_CHANGED(): string;
            /**
                * Event name for compiler options changing.
                * @const {string}
                */
            static get COMPILER_OPTIONS_CHANGED(): string;
            /**
                * Event name for framerate changing.
                * @const {string}
                */
            static get FRAMERATE_CHANGED(): string;
            static get TARGETS_INDEX_CHANGED(): string;
            /**
                * Event name for interpolation changing.
                * @const {string}
                */
            static get INTERPOLATION_CHANGED(): string;
            /**
                * Event name for stage size changing.
                * @const {string}
                */
            static get STAGE_SIZE_CHANGED(): string;
            /**
                * Event name for compiler errors.
                * @const {string}
                */
            static get COMPILE_ERROR(): string;
            /**
                * Event name for CCWAPI changing.
                * @const {string}
                */
            static get CCWAPI_CHANGED(): string;
            /**
                * Event name for assets loading progress.
                */
            static get LOAD_ASSETS_PROGRESS(): string;
            static get LOAD_ASSET_FAILED(): string;
            /**
                * Event name for start load a project from a Scratch JSON representation.
                * @const {string}
                */
            static get START_DESERIALIZE_PROJECT(): string;
            /**
                * Event name for the project completes loading the assets asynchronously
                * @const {string}
                */
            static get PROJECT_ASSETS_ASYNC_LOAD_DONE(): string;
            /**
                * Event called before any block is executed.
                */
            static get BEFORE_EXECUTE(): string;
            /**
                * Event called after every block in the project has been executed.
                */
            static get AFTER_EXECUTE(): string;
            /**
                * Event name for reporting asset download progress. Fired with finished, total
                * @const {string}
                */
            static get ASSET_PROGRESS(): string;
            /**
                * Event name when the project is started (threads may not necessarily be
                * running).
                * @const {string}
                */
            static get PROJECT_START(): string;
            /**
                * Event name when threads start running.
                * Used by the UI to indicate running status.
                * @const {string}
                */
            static get PROJECT_RUN_START(): string;
            /**
                * Event name when threads stop running
                * Used by the UI to indicate not-running status.
                * @const {string}
                */
            static get PROJECT_RUN_STOP(): string;
            /**
                * Event name for pause.
                * Used by the UI to indicate pause status.
                * @const {string}
                */
            static get PROJECT_RUN_PAUSE(): string;
            /**
                * Event name for resume
                * Used by the UI to indicate resume status.
                * @const {string}
                */
            static get PROJECT_RUN_RESUME(): string;
            /**
                * Event name for project being stopped or restarted by the user.
                * Used by blocks that need to reset state.
                * @const {string}
                */
            static get PROJECT_STOP_ALL(): string;
            /**
                * Event name for target being stopped by a stop for target call.
                * Used by blocks that need to stop individual targets.
                * @const {string}
                */
            static get STOP_FOR_TARGET(): string;
            /**
                * Event name for visual value report.
                * @const {string}
                */
            static get VISUAL_REPORT(): string;
            /**
                * Event name for project loaded report.
                * @const {string}
                */
            static get PROJECT_LOADED(): string;
            /**
                * Event name for report that a change was made that can be saved
                * @const {string}
                */
            static get PROJECT_CHANGED(): string;
            /**
                * Event name for mobile buttons visible was changed.
                * @const {string}
                */
            static get TARGET_BLOCKS_CHANGED(): string;
            /**
                * Event name for editing target's blocks was changed.
                * @const {string}
                */
            static get MOBILE_BUTTONS_VISIBLE_CHANGED(): string;
            /**
                * Event name for editing target's simple property(name, size, x, y, etc) was changed.
                * @const {string}
                */
            static get TARGET_SIMPLE_PROPERTY_CHANGED(): string;
            /**
                * Event name for editing target's comments was changed.
                * @const {string}
                */
            static get TARGET_COMMENTS_CHANGED(): string;
            /**
                * Event name for editing target's frames was changed.
                * @const {string}
                */
            static get TARGET_FRAMES_CHANGED(): string;
            /**
                * Event name for editing target's costome was changed.
                * @const {string}
                */
            static get TARGET_COSTUME_CHANGED(): string;
            /**
                * Event name for editing target's currentCostome was changed.
                * @const {string}
                */
            static get TARGET_CURRENT_COSTUME_CHANGED(): string;
            /**
                * Event name for editing target's variables was changed.
                * @const {string}
                */
            static get TARGET_VARIABLES_CHANGED(): string;
            /**
                * Event name for user manipulated monitor and caused it to change.
                * @const {string}
                */
            static get MONITORS_CHANGED(): string;
            /**
                * Event name for report that a change was made to an extension in the toolbox.
                * @const {string}
                */
            static get TOOLBOX_EXTENSIONS_NEED_UPDATE(): string;
            /**
                * Event name for targets update report.
                * @const {string}
                */
            static get TARGETS_UPDATE(): string;
            /**
                * Event name for target update report.
                * @const {string}
                */
            static get TARGET_UPDATE(): string;
            /**
                * Event name for gandi asset update report.
                * @const {string}
                */
            static get GANDI_ASSET_UPDATE(): string;
            static get GANDI_ASSET_UPDATE_FROM_SERVER(): string;
            static get GANDI_CONFIGS_UPDATE(): string;
            static get GANDI_SPINE_UPDATE(): string;
            static get GANDI_DYNAMIC_MENU_ITEMS_UPDATE(): string;
            static get GANDI_WILD_EXTENSIONS_CHANGED(): string;
            static get GANDI_SHOW_SPINE_UPLOAD(): string;
            /**
                * Event name for monitors update.
                * @const {string}
                */
            static get MONITORS_UPDATE(): string;
            /**
                * Event name for monitors changed.
                * @const {string}
                */
            static get SOUNDS_CHANGED(): string;
            /**
                * Event name for block drag update.
                * @const {string}
                */
            static get BLOCK_DRAG_UPDATE(): string;
            /**
                * Event name for frame drag update.
                * @const {string}
                */
            static get FRAME_DRAG_UPDATE(): string;
            /**
                * Event name for frame drag update.
                * @const {string}
                */
            static get FRAME_DRAG_END(): string;
            /**
                * Event name for block drag end.
                * @const {string}
                */
            static get BLOCK_DRAG_END(): string;
            /**
                * Event name for reporting that an extension was added.
                * @const {string}
                */
            static get EXTENSION_ADDED(): string;
            /**
                * Event name for reporting that an extension was deleted.
                * @const {string}
                */
            static get EXTENSION_DELETED(): string;
            /**
                * Event name for reporting that an extension as asked for a custom field to be added
                * @const {string}
                */
            static get EXTENSION_FIELD_ADDED(): string;
            /**
                * Event name for updating the available set of peripheral devices.
                * This causes the peripheral connection modal to update a list of
                * available peripherals.
                * @const {string}
                */
            static get PERIPHERAL_LIST_UPDATE(): string;
            /**
                * Event name for when the user picks a bluetooth device to connect to
                * via Companion Device Manager (CDM)
                * @const {string}
                */
            static get USER_PICKED_PERIPHERAL(): string;
            /**
                * Event name for reporting that a peripheral has connected.
                * This causes the status button in the blocks menu to indicate 'connected'.
                * @const {string}
                */
            static get PERIPHERAL_CONNECTED(): string;
            /**
                * Event name for reporting that a peripheral has been intentionally disconnected.
                * This causes the status button in the blocks menu to indicate 'disconnected'.
                * @const {string}
                */
            static get PERIPHERAL_DISCONNECTED(): string;
            /**
                * Event name for reporting that a peripheral has encountered a request error.
                * This causes the peripheral connection modal to switch to an error state.
                * @const {string}
                */
            static get PERIPHERAL_REQUEST_ERROR(): string;
            /**
                * Event name for reporting that a peripheral connection has been lost.
                * This causes a 'peripheral connection lost' error alert to display.
                * @const {string}
                */
            static get PERIPHERAL_CONNECTION_LOST_ERROR(): string;
            /**
                * Event name for reporting that a peripheral has not been discovered.
                * This causes the peripheral connection modal to show a timeout state.
                * @const {string}
                */
            static get PERIPHERAL_SCAN_TIMEOUT(): string;
            /**
                * Event name to indicate that the microphone is being used to stream audio.
                * @const {string}
                */
            static get MIC_LISTENING(): string;
            /**
                * Event name to indicate that the custom blocks have been added or deleted.
                * @const {string}
                */
            static get CUSTOM_BLOCK_ARGUMENTS_LENGTH_CHANGED(): string;
            static get EXTENSION_DATA_LOADING(): string;
            /**
                * Event name for reporting that blocksInfo was updated.
                * @const {string}
                */
            static get BLOCKSINFO_UPDATE(): string;
            /**
                * Event name when the runtime tick loop has been started.
                * @const {string}
                */
            static get RUNTIME_STARTED(): string;
            /**
                * Event name when the runtime tick loop has been stopped.
                * @const {string}
                */
            static get RUNTIME_STOPPED(): string;
            /**
                * Event name when the runtime dispose has been called.
                * @const {string}
                */
            static get RUNTIME_DISPOSED(): string;
            /**
                * Event name for reporting that a block was updated and needs to be rerendered.
                * @const {string}
                */
            static get BLOCKS_NEED_UPDATE(): string;
            /**
                * Event name when platform name inside a project does not match the runtime.
                */
            static get PLATFORM_MISMATCH(): string;
            /**
                * How rapidly we try to step threads by default, in ms.
                */
            static get THREAD_STEP_INTERVAL(): number;
            /**
                * In compatibility mode, how rapidly we try to step threads, in ms.
                */
            static get THREAD_STEP_INTERVAL_COMPATIBILITY(): number;
            /**
                * How many clones can be created at a time.
                * @const {number}
                */
            static get MAX_CLONES(): number;
            constructor();
            /**
                * Target management and storage.
                * @type {Array.<!Target>}
                */
            targets: Array<Target>;
            /**
                * Targets in reverse order of execution. Shares its order with drawables.
                * @type {Array.<!Target>}
                */
            executableTargets: Array<Target>;
            /**
                * A list of threads that are currently running in the VM.
                * Threads are added when execution starts and pruned when execution ends.
                * @type {Array.<Thread>}
                */
            threads: Array<Thread>;
            threadMap: Map<any, any>;
            /** @type {!Sequencer} */
            sequencer: Sequencer;
            /**
                * Storage container for flyout blocks.
                * These will execute on `_editingTarget.`
                * @type {!Blocks}
                */
            flyoutBlocks: Blocks;
            /**
                * Storage container for monitor blocks.
                * These will execute on a target maybe
                * @type {!Blocks}
                */
            monitorBlocks: Blocks;
            /**
                * Currently known editing target for the VM.
                * @type {?Target}
                */
            _editingTarget: Target | null;
            /**
                * Map to look up a block primitive's implementation function by its opcode.
                * This is a two-step lookup: package name first, then primitive name.
                * @type {Object.<string, Function>}
                */
            _primitives: {
                    [x: string]: Function;
            };
            /**
                * Map to look up hat blocks' metadata.
                * Keys are opcode for hat, values are metadata objects.
                * @type {Object.<string, Object>}
                */
            _hats: {
                    [x: string]: Object;
            };
            /**
                * Map of opcode to information about whether the block's return value should be interpreted
                * for control flow purposes.
                * @type {Record<string, {conditional: boolean}>}
                */
            _flowing: Record<string, {
                    conditional: boolean;
            }>;
            /**
                * A list of script block IDs that were glowing during the previous frame.
                * @type {!Array.<!string>}
                */
            _scriptGlowsPreviousFrame: Array<string>;
            /**
                * Number of non-monitor threads running during the previous frame.
                * @type {number}
                */
            _nonMonitorThreadCount: number;
            /**
                * All threads that finished running and were removed from this.threads
                * by behaviour in Sequencer.stepThreads.
                * @type {Array<Thread>}
                */
            _lastStepDoneThreads: Array<Thread>;
            /**
                * Currently known number of clones, used to enforce clone limit.
                * @type {number}
                */
            _cloneCounter: number;
            /**
                * Flag to emit a targets update at the end of a step. When target data
                * changes, this flag is set to true.
                * @type {boolean}
                */
            _refreshTargets: boolean;
            /**
                * Ordered map of all monitors, which are MonitorReporter objects.
                */
            _monitorState: OrderedMap<string, any>;
            /**
                * Monitor state from last tick
                */
            _prevMonitorState: OrderedMap<string, any>;
            /**
                * Whether the project is in "turbo mode."
                * @type {Boolean}
                */
            turboMode: boolean;
            /**
                * tw: Responsible for managing the VM's many timers.
                */
            frameLoop: FrameLoop;
            /**
                * Current length of a step.
                * Changes as mode switches, and used by the sequencer to calculate
                * WORK_TIME.
                * @type {!number}
                */
            currentStepTime: number;
            /**
                * Whether any primitive has requested a redraw.
                * Affects whether `Sequencer.stepThreads` will yield
                * after stepping each thread.
                * Reset on every frame.
                * @type {boolean}
                */
            redrawRequested: boolean;
            /** @type {Object.<string, Object>} */
            ioDevices: {
                    [x: string]: Object;
            };
            /**
                * A list of extensions, used to manage hardware connection.
                */
            peripheralExtensions: {};
            /**
                * A runtime profiler that records timed events for later playback to
                * diagnose Scratch performance.
                * @type {Profiler}
                */
            profiler: Profiler;
            cloudOptions: {
                    limit: number;
            };
            /**
                * Check wether the runtime has any cloud data.
                * @type {function}
                * @return {boolean} Whether or not the runtime currently has any
                * cloud variables.
                */
            hasCloudData: Function;
            /**
                * A function which checks whether a new cloud variable can be added
                * to the runtime.
                * @type {function}
                * @return {boolean} Whether or not a new cloud variable can be added
                * to the runtime.
                */
            canAddCloudVariable: Function;
            /**
                * A function which returns the number of cloud variables in the runtime.
                * @returns {number}
                */
            getNumberOfCloudVariables: Function;
            /**
                * A function that tracks a new cloud variable in the runtime,
                * updating the cloud variable limit. Calling this function will
                * emit a cloud data update event if this is the first cloud variable
                * being added.
                * @type {function}
                */
            addCloudVariable: Function;
            /**
                * A function which updates the runtime's cloud variable limit
                * when removing a cloud variable and emits a cloud update event
                * if the last of the cloud variables is being removed.
                * @type {function}
                */
            removeCloudVariable: Function;
            /**
                * A string representing the origin of the current project from outside of the
                * Scratch community, such as CSFirst.
                * @type {?string}
                */
            origin: string | null;
            /**
                * Provides the ability to log to the terminal.
                * The default output is to the browser's console
                * @type {LogSystem}
                */
            logSystem: LogSystem;
            /**
                * New data structure in Gandi editor.
                * @type {Gandi}
                */
            gandi: Gandi;
            _stageTarget: any;
            /**
                * Metadata about the platform this VM is part of.
                */
            platform: {
                    name: string;
                    url: string;
            };
            addonBlocks: {};
            stageWidth: number;
            stageHeight: number;
            runtimeOptions: {
                    maxClones: number;
                    miscLimits: boolean;
                    fencing: boolean;
                    hatsConcurrency: number;
            };
            compilerOptions: {
                    enabled: boolean;
                    warpTimer: boolean;
            };
            /** ccw: add ccwAPI init value {}
                *
                */
            ccwAPI: {};
            waitingLoadAssetCallbackQueue: any[];
            debug: boolean;
            _lastStepTime: number;
            interpolationEnabled: boolean;
            _defaultStoredSettings: {
                    framerate: any;
                    runtimeOptions: {
                            maxClones: number;
                            miscLimits: boolean;
                            fencing: boolean;
                            hatsConcurrency: number;
                    };
                    interpolation: boolean;
                    turbo: boolean;
                    hq: any;
                    width: number;
                    height: number;
            };
            /**
                * TW: We support a "packaged runtime" mode. This can be used when:
                *  - there will never be an editor attached such as scratch-gui or scratch-blocks
                *  - the project will never be exported with saveProjectSb3()
                *  - original costume and sound data is not needed
                * In this mode, the runtime is able to discard large amounts of data and avoid some processing
                * to make projects load faster and use less memory.
                * This is not designed to protect projects from copying as someone can still copy the data that
                * gets fed into the runtime in the first place.
                * This mode is used by the TurboWarp Packager.
                */
            isPackaged: boolean;
            /**
                * Contains information about the external communication methods that the scripts inside the project
                * can use to send data from inside the project to an external server.
                * Do not update this directly. Use Runtime.setExternalCommunicationMethod() instead.
                */
            externalCommunicationMethods: {
                    cloudVariables: boolean;
                    customExtensions: boolean;
            };
            /**
                * If set to true, features such as reading colors from the user's webcam will be disabled
                * when the project has access to any external communication method to protect user privacy.
                * Requires TurboWarp/scratch-render.
                * Do not update this directly. Use Runtime.setEnforcePrivacy() instead.
                */
            enforcePrivacy: boolean;
            /**
                * Internal map of opaque identifiers to the callback to run that function.
                * @type {Map<string, function>}
                */
            extensionButtons: Map<string, Function>;
            /**
                * Responsible for managing custom fonts.
                */
            fontManager: FontManager;
            /**
                * Maps extension ID to a JSON-serializable value.
                * @type {Object.<string, object>}
                */
            extensionStorage: {
                    [x: string]: object;
            };
            /**
                * Total number of scratch-storage load() requests since the runtime was created or cleared.
                */
            totalAssetRequests: number;
            /**
                * Total number of finished or errored scratch-storage load() requests since the runtime was created or cleared.
                */
            finishedAssetRequests: number;
            _initializeAddCloudVariable(newCloudDataManager: any): () => void;
            _initializeRemoveCloudVariable(newCloudDataManager: any): () => void;
            compilerRegisterExtension(name: any, extensionObject: any): void;
            getMonitorState(): OrderedMap<string, any>;
            /**
                * Create a context ("args") object for use with `formatMessage` on messages which might be target-specific.
                * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current
                * editing target or the stage.
                */
            makeMessageContextForTarget(target?: Target): void;
            /**
                * remove extension
                * @param  {string} extensionId - id of extension to remove
                */
            removeExtensionPrimitives(extensionId: string): void;
            _buildCustomFieldInfo(fieldName: any, fieldInfo: any, extensionId: any, categoryInfo: any): {
                    fieldName: any;
                    extendedName: string;
                    argumentTypeInfo: {
                            shadow: {
                                    type: string;
                                    fieldName: string;
                            };
                    };
                    scratchBlocksDefinition: object;
                    fieldImplementation: any;
            };
            /**
                * Build the scratch-blocks JSON needed for a fieldType.
                * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other
                * @param  {string} fieldName - The name of the field
                * @param {string} output - The output of the field
                * @param {number} outputShape - Shape of the field (from ScratchBlocksConstants)
                * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)
                * @returns {object} - Object to be inserted into scratch-blocks
                */
            _buildCustomFieldTypeForScratchBlocks(fieldName: string, output: string, outputShape: number, categoryInfo: object): object;
            _convertXmlForScratchBlocks(xmlInfo: any): {
                    info: any;
                    xml: any;
            };
            handleExtensionButtonPress(button: any): void;
            /**
                * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.
                * @param {?Target} [target] - the active editing target (optional)
                * @property {string} id - the category / extension ID
                * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`
                */
            getBlocksXML(target?: Target | null): Array<object>;
            /**
                * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.
                */
            getBlocksJSON(): Array<string>;
            /**
                * One-time initialization for Scratch Link support.
                */
            _initScratchLink(): void;
            /**
                * Get a scratch link socket.
                * @param {string} type Either BLE or BT
                * @returns {ScratchLinkSocket} The scratch link socket.
                */
            getScratchLinkSocket(type: string): ScratchLinkSocket;
            /**
                * Configure how ScratchLink sockets are created. Factory must consume a "type" parameter
                * either BT or BLE.
                * @param {Function} factory The new factory for creating ScratchLink sockets.
                */
            configureScratchLinkSocketFactory(factory: Function): void;
            _linkSocketFactory: Function | undefined;
            /**
                * The default scratch link socket creator, using websockets to the installed device manager.
                * @param {string} type Either BLE or BT
                * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)
                */
            _defaultScratchLinkSocketFactory(type: string): ScratchLinkSocket;
            /**
                * Register an extension that communications with a hardware peripheral by id,
                * to have access to it and its peripheral functions in the future.
                * @param {string} extensionId - the id of the extension.
                * @param {object} extension - the extension to register.
                */
            registerPeripheralExtension(extensionId: string, extension: object): void;
            /**
                * Tell the specified extension to scan for a peripheral.
                * @param {string} extensionId - the id of the extension.
                */
            scanForPeripheral(extensionId: string): void;
            /**
                * Connect to the extension's specified peripheral.
                * @param {string} extensionId - the id of the extension.
                * @param {number} peripheralId - the id of the peripheral.
                */
            connectPeripheral(extensionId: string, peripheralId: number): void;
            /**
                * Disconnect from the extension's connected peripheral.
                * @param {string} extensionId - the id of the extension.
                */
            disconnectPeripheral(extensionId: string): void;
            /**
                * Returns whether the extension has a currently connected peripheral.
                * @param {string} extensionId - the id of the extension.
                * @return {boolean} - whether the extension has a connected peripheral.
                */
            getPeripheralIsConnected(extensionId: string): boolean;
            /**
                * Emit an event to indicate that the microphone is being used to stream audio.
                * @param {boolean} listening - true if the microphone is currently listening.
                */
            emitMicListening(listening: boolean): void;
            /**
                * Retrieve the function associated with the given opcode.
                * @param {!string} opcode The opcode to look up.
                * @return {Function} The function which implements the opcode.
                */
            getOpcodeFunction(opcode: string): Function;
            /**
                * Return whether an opcode represents a hat block.
                * @param {!string} opcode The opcode to look up.
                * @return {boolean} True if the op is known to be a hat.
                */
            getIsHat(opcode: string): boolean;
            /**
                * Return whether an opcode represents an edge-activated hat block.
                * @param {!string} opcode The opcode to look up.
                * @return {boolean} True if the op is known to be a edge-activated hat.
                */
            getIsEdgeActivatedHat(opcode: string): boolean;
            /**
                * Attach the audio engine
                * @param {!AudioEngine} audioEngine The audio engine to attach
                */
            attachAudioEngine(audioEngine: AudioEngine): void;
            audioEngine: any;
            /**
                * Attach the renderer
                * @param {!RenderWebGL} renderer The renderer to attach
                */
            attachRenderer(renderer: RenderWebGL): void;
            renderer: any;
            /**
                * Set the bitmap adapter for the VM/runtime, which converts scratch 2
                * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)
                * @param {!function} bitmapAdapter The adapter to attach
                */
            attachV2BitmapAdapter(bitmapAdapter: Function): void;
            v2BitmapAdapter: Function | undefined;
            /**
                * Attach the storage module
                * @param {!ScratchStorage} storage The storage module to attach
                */
            attachStorage(storage: ScratchStorage): void;
            storage: any;
            attachBlocks(scratchBlocks: any): void;
            scratchBlocks: any;
            /**
                * Create a thread and push it to the list of threads.
                * @param {!string} id ID of block that starts the stack.
                * @param {!Target} target Target to run thread on.
                * @param {?object} opts optional arguments
                * @param {?boolean} opts.stackClick true if the script was activated by clicking on the stack
                * @param {?boolean} opts.updateMonitor true if the script should update a monitor value
                * @param {?object} opts.hatParam store ccw_hat_parameter
                * @return {!Thread} The newly created thread.
                */
            _pushThread(id: string, target: Target, opts: object | null): Thread;
            /**
                * Stop a thread: stop running it immediately, and remove it from the thread list later.
                * @param {!Thread} thread Thread object to remove from actives
                */
            _stopThread(thread: Thread): void;
            /**
                * Restart a thread in place, maintaining its position in the list of threads.
                * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.
                * Test project: https://scratch.mit.edu/projects/130183108/
                * @param {!Thread} thread Thread object to restart.
                * @return {Thread} The restarted thread.
                */
            _restartThread(thread: Thread): Thread;
            emitCompileError(target: any, error: any): void;
            /**
                * Return whether a thread is currently active/running.
                * @param {?Thread} thread Thread object to check.
                * @return {boolean} True if the thread is active/running.
                */
            isActiveThread(thread: Thread | null): boolean;
            /**
                * Return whether a thread is waiting for more information or done.
                * @param {?Thread} thread Thread object to check.
                * @return {boolean} True if the thread is waiting
                */
            isWaitingThread(thread: Thread | null): boolean;
            /**
                * Toggle a script.
                * @param {!string} topBlockId ID of block that starts the script.
                * @param {?object} opts optional arguments to toggle script
                * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.
                * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This
                *     determines whether we show a visual report when turning on the script.
                */
            toggleScript(topBlockId: string, opts: object | null): void;
            /**
                * Enqueue a script that when finished will update the monitor for the block.
                * @param {!string} topBlockId ID of block that starts the script.
                * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.
                */
            addMonitorScript(topBlockId: string, optTarget: Target | null): void;
            /**
                * Run a function `f` for all scripts in a workspace.
                * `f` will be called with two parameters:
                *  - the top block ID of the script.
                *  - the target that owns the script.
                * @param {!Function} f Function to call for each script.
                * @param {Target=} optTarget Optionally, a target to restrict to.
                */
            allScriptsDo(f: Function, optTarget?: Target | undefined): void;
            allScriptsByOpcodeDo(opcode: any, f: any, optTarget: any): void;
            /**
                * Start all relevant hats.
                * @param {!string} requestedHatOpcode Opcode of hats to start.
                * @param {object=} optMatchFields Optionally, fields to match on the hat.
                * @param {Target=} optTarget Optionally, a target to restrict to.
                * @param {object=} hatParam Optionally, start hats with ccw_hat_parameter if true,
                                                                            will skip field check and inject ccw_hat_parameter to thread.
                * @return {Array.<Thread>} List of threads started by this function.
                */
            startHats(requestedHatOpcode: string, optMatchFields?: object | undefined, optTarget?: Target | undefined, hatParam?: object | undefined): Array<Thread>;
            /**
                * CCW
                    startHatsWithParams is only used in block utility for extension,
                    WhitExtraMsg means skip field check when start a hat block.
                    define here is only for debug
                * @param {!string} requestedHatOpcode Opcode of hats to start.
                * @param {object} data Optionally, contains fields to match on the hat and parameters to ccw_hat_parameter.
                * @param {Target=} optTarget Optionally, a target to restrict to.
                * @return {Array.<Thread>} List of threads started by this function.
                */
            startHatsWithParams(requestedHat: any, data: object, optTarget?: Target | undefined): Array<Thread>;
            /**
                * Dispose all targets. Return to clean state.
                */
            dispose(): void;
            disposeAll(): void;
            _steppingInterval: any;
            /**
                * Add a target to the runtime. This tracks the sprite pane
                * ordering of the target. The target still needs to be put
                * into the correct execution order after calling this function.
                * @param {Target} target target to add
                */
            addTarget(target: Target): void;
            /**
                * Move a target in the execution order by a relative amount.
                *
                * A positve number will make the target execute earlier. A negative number
                * will make the target execute later in the order.
                *
                * @param {Target} executableTarget target to move
                * @param {number} delta number of positions to move target by
                * @returns {number} new position in execution order
                */
            moveExecutable(executableTarget: Target, delta: number): number;
            /**
                * Set a target to execute at a specific position in the execution order.
                *
                * Infinity will set the target to execute first. 0 will set the target to
                * execute last (before the stage).
                *
                * @param {Target} executableTarget target to move
                * @param {number} newIndex position in execution order to place the target
                * @returns {number} new position in the execution order
                */
            setExecutablePosition(executableTarget: Target, newIndex: number): number;
            /**
                * Remove a target from the execution set.
                * @param {Target} executableTarget target to remove
                */
            removeExecutable(executableTarget: Target): void;
            /**
                * Dispose of a target.
                * @param {!Target} disposingTarget Target to dispose of.
                */
            disposeTarget(disposingTarget: Target): void;
            /**
                * Stop any threads acting on the target.
                * @param {!Target} target Target to stop threads for.
                * @param {Thread=} optThreadException Optional thread to skip.
                */
            stopForTarget(target: Target, optThreadException?: Thread | undefined): void;
            /**
                * Reset the Run ID. Call this any time the project logically starts, stops, or changes identity.
                */
            resetRunId(): void;
            /**
                * Start all threads that start with the green flag.
                */
            greenFlag(): void;
            /**
                * Stop "everything."
                */
            stopAll(): void;
            _renderInterpolatedPositions(): void;
            updateThreadMap(): void;
            /**
                * Repeatedly run `sequencer.stepThreads` and filter out
                * inactive threads after each iteration.
                */
            _step(): void;
            /**
                * Get the number of threads in the given array that are monitor threads (threads
                * that update monitor values, and don't count as running a script).
                * @param {!Array.<Thread>} threads The set of threads to look through.
                * @return {number} The number of monitor threads in threads.
                */
            _getMonitorThreadCount(threads: Array<Thread>): number;
            /**
                * Queue monitor blocks to sequencer to be run.
                */
            _pushMonitors(): void;
            /**
                * Set the current editing target known by the runtime.
                * @param {!Target} editingTarget New editing target.
                */
            setEditingTarget(editingTarget: Target): void;
            /**
                * Set whether we are in 30 TPS compatibility mode.
                * @param {boolean} compatibilityModeOn True iff in compatibility mode.
                */
            setCompatibilityMode(compatibilityModeOn: boolean): void;
            /**
                * tw: Change runtime target frames per second
                * @param {number} framerate Target frames per second
                */
            setFramerate(framerate: number): void;
            /**
                * tw: Enable or disable interpolation.
                * @param {boolean} interpolationEnabled True if interpolation should be enabled.
                */
            setInterpolation(interpolationEnabled: boolean): void;
            /**
                * tw: Update runtime options
                * @param {*} runtimeOptions New options
                */
            setRuntimeOptions(runtimeOptions: any): void;
            /**
                * ccw: Set ccw API to runtime support ccw block extensions
                * @param {*} ccwAPI ccw API
                */
            setCCWAPI(ccwAPI: any): void;
            /**
                * tw: Update compiler options
                * @param {*} compilerOptions New options
                */
            setCompilerOptions(compilerOptions: any): void;
            /**
                * @param {boolean} isPlayerOnly
                */
            setIsPlayerOnly(isPlayerOnly: boolean): void;
            isPlayerOnly: boolean | undefined;
            /**
                * Change width and height of stage. This will also inform the renderer of the new stage size.
                * @param {number} width New stage width
                * @param {number} height New stage height
                */
            setStageSize(width: number, height: number): void;
            setInEditor(inEditor: any): void;
            /**
                * TW: Enable "packaged runtime" mode. This is a one-way operation.
                */
            convertToPackagedRuntime(): void;
            /**
                * tw: Reset the cache of all block containers.
                */
            resetAllCaches(): void;
            /**
                * Add an "addon block"
                * @param {object} options Options object
                * @param {string} options.procedureCode The ID of the block
                * @param {function} options.callback The callback, called with (args, BlockUtility). May return a promise.
                * @param {string[]} [options.arguments] Names of the arguments accepted. Optional if no arguments.
                * @param {boolean} [options.hidden] True to not include this block in the block palette
                * @param {1|2} [options.return] 1 for round reporter, 2 for boolean reported, leave empty for statement.
                */
            addAddonBlock(options: {
                    procedureCode: string;
                    callback: Function;
                    arguments?: string[] | undefined;
                    hidden?: boolean | undefined;
                    return?: 2 | 1 | undefined;
            }): void;
            getAddonBlock(procedureCode: any): any;
            findProjectOptionsComment(): any;
            parseProjectOptions(): void;
            _generateAllProjectOptions(): {
                    framerate: any;
                    runtimeOptions: {
                            maxClones: number;
                            miscLimits: boolean;
                            fencing: boolean;
                            hatsConcurrency: number;
                    };
                    interpolation: boolean;
                    turbo: boolean;
                    hq: any;
                    width: number;
                    height: number;
            };
            generateDifferingProjectOptions(): {};
            storeProjectOptions(): void;
            /**
                * Eagerly (re)compile all scripts within this project.
                */
            precompile(): void;
            enableDebug(): void;
            /**
                * Emit glows/glow clears for scripts after a single tick.
                * Looks at `this.threads` and notices which have turned on/off new glows.
                * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.
                */
            _updateGlows(optExtraThreads?: Array<Thread> | undefined): void;
            /**
                * Emit run start/stop after each tick. Emits when `this.threads.length` goes
                * between non-zero and zero
                *
                * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount
                */
            _emitProjectRunStatus(nonMonitorThreadCount: number): void;
            /**
                * "Quiet" a script's glow: stop the VM from generating glow/unglow events
                * about that script. Use when a script has just been deleted, but we may
                * still be tracking glow data about it.
                * @param {!string} scriptBlockId Id of top-level block in script to quiet.
                */
            quietGlow(scriptBlockId: string): void;
            /**
                * Emit feedback for block glowing (used in the sequencer).
                * @param {?string} blockId ID for the block to update glow
                * @param {boolean} isGlowing True to turn on glow; false to turn off.
                */
            glowBlock(blockId: string | null, isGlowing: boolean): void;
            /**
                * Emit feedback for script glowing.
                * @param {?string} topBlockId ID for the top block to update glow
                * @param {boolean} isGlowing True to turn on glow; false to turn off.
                */
            glowScript(topBlockId: string | null, isGlowing: boolean): void;
            /**
                * Emit whether blocks are being dragged over gui
                * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise
                */
            emitBlockDragUpdate(areBlocksOverGui: boolean): void;
            /**
                * Emit whether frame are being dragged over gui
                * @param {boolean} areBlocksOverGui True if frame are dragged out of the workspace, false otherwise
                */
            emitFrameDragUpdate(areBlocksOverGui: boolean): void;
            /**
                * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace
                * @param {Array.<object>} blocks The set of blocks dragged to the GUI
                * @param {string} topBlockId The original id of the top block being dragged
                * @param {Array.<object>} newBatchElements The set of batch selected blocks or frames
                */
            emitBlockEndDrag(blocks: Array<object>, topBlockId: string, newBatchElements: Array<object>): void;
            /**
                * Emit event to indicate that the frame drag has ended with the blocks outside the blocks workspace
                * @param {Array.<object>} frame The frame dragged to the GUI
                * @param {string} frameId The original id of the frame being dragged
                * @param {Array.<object>=} newBatchElements The set of batch selected blocks or frames
                */
            emitFrameEndDrag(frame: Array<object>, frameId: string, newBatchElements?: Array<object> | undefined): void;
            emitGandiSpineUpdate(type: any, id: any, data: any): void;
            emitGandiConfigsUpdate(key: any, value: any): void;
            emitGandiDynamicMenuItemsUpdate(type: any, id: any, data: any): void;
            /**
                * Emit value for reporter to show in the blocks.
                * @param {string} blockId ID for the block.
                * @param {string} value Value to show associated with the block.
                */
            visualReport(blockId: string, value: string): void;
            /**
                * Add a monitor to the state. If the monitor already exists in the state,
                * updates those properties that are defined in the given monitor record.
                * @param {!MonitorRecord} monitor Monitor to add.
                * @param {boolean} isRemoteOperation - set to true if this is a remote operation
                */
            requestAddMonitor(monitor: MonitorRecord, isRemoteOperation: boolean): void;
            /**
                * Update a monitor in the state and report success/failure of update.
                * @param {!Map} monitor Monitor values to update. Values on the monitor with overwrite
                *     values on the old monitor with the same ID. If a value isn't defined on the new monitor,
                *     the old monitor will keep its old value.
                * @return {boolean} true if monitor exists in the state and was updated, false if it did not exist.
                */
            requestUpdateMonitor(monitor: Map<any, any>): boolean;
            /**
                * Removes a monitor from the state. Does nothing if the monitor already does
                * not exist in the state.
                * @param {!string} monitorId ID of the monitor to remove.
                * @param {boolean} isRemoteOperation - set to true if this is a remote operation
                */
            requestRemoveMonitor(monitorId: string, isRemoteOperation: boolean): void;
            /**
                * Hides a monitor and returns success/failure of action.
                * @param {!string} monitorId ID of the monitor to hide.
                * @param {boolean} isRuntimeOp Whether it is an operation at run time
                * @return {boolean} true if monitor exists and was updated, false otherwise
                */
            requestHideMonitor(monitorId: string, isRuntimeOp: boolean): boolean;
            /**
                * Shows a monitor and returns success/failure of action.
                * not exist in the state.
                * @param {!string} monitorId ID of the monitor to show.
                * @param {boolean} isRuntimeOp Whether it is an operation at run time
                * @return {boolean} true if monitor exists and was updated, false otherwise
                */
            requestShowMonitor(monitorId: string, isRuntimeOp: boolean): boolean;
            /**
                * Removes all monitors with the given target ID from the state. Does nothing if
                * the monitor already does not exist in the state.
                * @param {!string} targetId Remove all monitors with given target ID.
                */
            requestRemoveMonitorByTargetId(targetId: string): void;
            /**
                * Get a target by its id.
                * @param {string} targetId Id of target to find.
                * @return {?Target} The target, if found.
                */
            getTargetById(targetId: string): Target | null;
            /**
                * Get the first original (non-clone-block-created) sprite given a name.
                * @param {string} spriteName Name of sprite to look for.
                * @return {?Target} Target representing a sprite of the given name.
                */
            getSpriteTargetByName(spriteName: string): Target | null;
            /**
                * Get a target by its drawable id.
                * @param {number} drawableID drawable id of target to find
                * @return {?Target} The target, if found
                */
            getTargetByDrawableId(drawableID: number): Target | null;
            /**
                * Update the clone counter to track how many clones are created.
                * @param {number} changeAmount How many clones have been created/destroyed.
                */
            changeCloneCounter(changeAmount: number): void;
            /**
                * Return whether there are clones available.
                * @return {boolean} True until the number of clones hits runtimeOptions.maxClones
                */
            clonesAvailable(): boolean;
            /**
                * Handle that the project has loaded in the Virtual Machine.
                */
            handleProjectLoaded(): void;
            /**
                * Report that the project has changed in a way that would affect serialization
                */
            emitProjectChanged(): void;
            emitCustomBlockArgumentsLengthChanged(): void;
            emitGandiAssetsUpdate(action: any): void;
            emitGandiAssetsUpdateFromServer(action: any): void;
            emitGandiWildExtensionsChanged(data: any): void;
            /**
                * Report that the project completes loading the assets asynchronously
                */
            emitProjectAssetsAsyncLoadingDone(): void;
            emitExtensionsChanged(): void;
            emitMobileButtonsVisibleChanged(value: any): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                */
            emitTargetBlocksChanged(targeId: any, blocks: any, ext: any): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                * @param {Array<Array<string, object>>} data - An array consisting of roles that have undergone changes.
                */
            emitTargetSimplePropertyChanged(data: Array<Array<string| object>>): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                */
            emitTargetCommentsChanged(targeId: any, data: any): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                */
            emitTargetFramesChanged(targeId: any, data: any): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                */
            emitTargetCostumeChanged(id: any, data: any): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                */
            emitTargetCurrentCostumeChanged(index: any): void;
            /**
                * Report that the target has changed in a way that would affect serialization
                */
            emitTargetVariablesChanged(id: any, data: any): void;
            emitMonitorsChanged(data: any): void;
            emitTargetsIndexChanged(data: any): void;
            /**
                * Report that the monitors has changed
                */
            emitTargetSoundsChanged(targetId: any, data: any): void;
            /**
                * Report that a new target has been created, possibly by cloning an existing target.
                * @param {Target} newTarget - the newly created target.
                * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
                * @fires Runtime#targetWasCreated
                */
            fireTargetWasCreated(newTarget: Target, sourceTarget?: Target): void;
            /**
                * Report that a clone target is being removed.
                * @param {Target} target - the target being removed
                * @fires Runtime#targetWasRemoved
                */
            fireTargetWasRemoved(target: Target): void;
            /**
                * Get a target representing the Scratch stage, if one exists.
                * @return {?Target} The target, if found.
                */
            getTargetForStage(): Target | null;
            /**
                * Get the editing target.
                * @return {?Target} The editing target.
                */
            getEditingTarget(): Target | null;
            getAllVarNamesOfType(varType: any): any[];
            /**
                * Get the label or label function for an opcode
                * @param {string} extendedOpcode - the opcode you want a label for
                * @return {object} - object with label and category
                * @property {string} category - the category for this opcode
                * @property {Function} [labelFn] - function to generate the label for this opcode
                * @property {string} [label] - the label for this opcode if `labelFn` is absent
                */
            getLabelForOpcode(extendedOpcode: string): object;
            /**
                * Create a new global variable avoiding conflicts with other variable names.
                * @param {string} variableName The desired variable name for the new global variable.
                * This can be turned into a fresh name as necessary.
                * @param {string} optVarId An optional ID to use for the variable. A new one will be generated
                * if a falsey value for this parameter is provided.
                * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.
                * @return {Variable} The new variable that was created.
                */
            createNewGlobalVariable(variableName: string, optVarId: string, optVarType: string): Variable;
            /**
                * Tell the runtime to request a redraw.
                * Use after a clone/sprite has completed some visible operation on the stage.
                */
            requestRedraw(): void;
            /**
                * Emit a targets update at the end of the step if the provided target is
                * the original sprite
                * @param {!Target} target Target requesting the targets update
                */
            requestTargetsUpdate(target: Target): void;
            /**
                * Emit an event that indicates that the blocks on the workspace need updating.
                */
            requestBlocksUpdate(): void;
            /**
                * Emit an event that indicates that the toolbox extension blocks need updating.
                */
            requestToolboxExtensionsUpdate(): void;
            /**
                * Set up timers to repeatedly step in a browser.
                */
            start(): void;
            /**
                * @deprecated Used by old versions of TurboWarp. Superceded by upstream's quit()
                */
            stop(): void;
            /**
                * Quit the Runtime, clearing any handles which might keep the process alive.
                * Do not use the runtime after calling this method. This method is meant for test shutdown.
                */
            quit(): void;
            /**
                * Turn on profiling.
                * @param {Profiler/FrameCallback} onFrame A callback handle passed a
                * profiling frame when the profiler reports its collected data.
                */
            enableProfiling(onFrame: any): void;
            /**
                * Turn off profiling.
                */
            disableProfiling(): void;
            /**
                * Update a millisecond timestamp value that is saved on the Runtime.
                * This value is helpful in certain instances for compatibility with Scratch 2,
                * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as
                */
            updateCurrentMSecs(): void;
            currentMSecs: number | undefined;
            getFormatMessage(message: any): (...args: any[]) => string;
            getOriginalFormatMessage(): typeof import("format-message");
            getGandiAssetsList(typesArray: any): any;
            getGandiAssetContent(fileName: any): any;
            getGandiAssetById(id: any): any;
            getGandiAssetsFileList(type: any): any;
            getGandiAssetFile(fileName: any): any;
            addWaitingLoadCallback(callback: any): void;
            fireWaitingLoadCallbackQueue(): void;
            firingWaitingLoadCallbackQueue: boolean | undefined;
            asyncLoadingProjectAssets: boolean | undefined;
            requestAnimationFrameId: any;
            /**
                * Cancel all completed asynchronous resource loading tasks
                */
            disposeFireWaitingLoadCallbackQueue(): void;
            /**
                * Add a costume to the current editing target.
                * async costume should only existed in project running
                * once project is stopped, all async costume should be removed
                * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
                * @param {!object} costumeObject Object representing the costume.
                * @param {object} target - the target to add to.
                * @param {?boolean} show - show Costume immediately
                * @returns {?Promise} - a promise that resolves when the costume has been added
                */
            addAsyncCostumeToTarget(md5ext: string, costumeObject: object, target: object, show: boolean | null): Promise<any> | null;
            updatePrivacy(): void;
            /**
                * @param {boolean} enabled True if restrictions should be enforced to protect user privacy.
                */
            setEnforcePrivacy(enabled: boolean): void;
            /**
                * @param {string} method Name of the method in Runtime.externalCommunicationMethods
                * @param {boolean} enabled True if the feature is enabled.
                */
            setExternalCommunicationMethod(method: string, enabled: boolean): void;
            emitAssetProgress(): void;
            resetProgress(): void;
            /**
                * Wrap an asset loading promise with progress support.
                * @template T
                * @param {() => Promise<T>} callback
                * @returns {Promise<T>}
                */
            wrapAssetRequest<T>(callback: () => Promise<T>): Promise<T>;
    }
    namespace Runtime {
            export { CloudDataManager };
    }
    import EventEmitter = require("events");
    import Thread = require("scratch-vm-dts/engine/thread");
    import Sequencer = require("scratch-vm-dts/engine/sequencer");
    import Blocks = require("scratch-vm-dts/engine/blocks");
    import { OrderedMap } from "immutable";
    import FrameLoop = require("scratch-vm-dts/engine/tw-frame-loop");
    import Profiler = require("scratch-vm-dts/engine/profiler");
    import LogSystem = require("scratch-vm-dts/util/log-system");
    import Gandi = require("scratch-vm-dts/util/gandi");
    import FontManager = require("scratch-vm-dts/engine/tw-font-manager");
    import Variable = require("scratch-vm-dts/engine/variable");
    /**
        * A pair of functions used to manage the cloud variable limit,
        * to be used when adding (or attempting to add) or removing a cloud variable.
        */
    type CloudDataManager = {
            /**
                * A function to call to check that
                * a cloud variable can be added.
                */
            canAddCloudVariable: Function;
            /**
                * A function to call to track a new
                * cloud variable on the runtime.
                */
            addCloudVariable: Function;
            /**
                * A function to call when
                * removing an existing cloud variable.
                */
            removeCloudVariable: Function;
            /**
                * A function to call to check that
                * the runtime has any cloud variables.
                */
            hasCloudVariables: Function;
            /**
                * A function that returns the
                * number of cloud variables in the project.
                */
            getNumberOfCloudVariables: Function;
    };
}

declare module 'scratch-vm-dts/extension-support/extension-manager' {
    export = ExtensionManager;
    class int extends Number{}
    class bool extends Boolean{}
    import ArgumentType from 'scratch-vm-dts/extension-support/argument-type';
    import VirtualMachine from 'scratch-vm-dts/virtual-machine';
    import Runtime from 'scratch-vm-dts/engine/runtime';
    import ExtensionBlockMetadata from 'scratch-vm-dts/extension-support/extension-metadata';
    
    import Scratch3CoreExample from "scratch-vm-dts/blocks/scratch3_core_example";
    import Scratch3PenBlocks from '../extensions/scratch3_pen'
    import Scratch3WeDo2Blocks from 'scratch-vm-dts/extensions/scratch3_wedo2';
    import Scratch3MicroBitBlocks from 'scratch-vm-dts/extensions/scratch3_microbit';
    import Scratch3Text2SpeechBlocks from 'scratch-vm-dts/extensions/scratch3_text2speech';
    import Scratch3TranslateBlocks from 'scratch-vm-dts/extensions/scratch3_translate';
    import Scratch3VideoSensingBlocks from 'scratch-vm-dts/extensions/scratch3_video_sensing';
    import Scratch3Ev3Blocks from 'scratch-vm-dts/extensions/scratch3_ev3';
    import Scratch3MakeyMakeyBlocks from 'scratch-vm-dts/extensions/scratch3_makeymakey';
    import Scratch3BoostBlocks from 'scratch-vm-dts/extensions/scratch3_boost';
    import Scratch3GdxForBlocks from 'scratch-vm-dts/extensions/scratch3_gdx_for';
    import TurboWarpBlocks from 'scratch-vm-dts/extensions/tw';
    class ExtensionManager {
            constructor(vm: any);
            /**
                * The ID number to provide to the next extension worker.
                * @type {int}
                */
            nextExtensionWorker: int;
            /**
                * FIFO queue of extensions which have been requested but not yet loaded in a worker,
                * along with promise resolution functions to call once the worker is ready or failed.
                *
                * @type {Array.<PendingExtensionWorker>}
                */
            pendingExtensions: Array<PendingExtensionWorker>;
            /**
                * Map of worker ID to workers which have been allocated but have not yet finished initialization.
                * @type {Array.<PendingExtensionWorker>}
                */
            pendingWorkers: Array<PendingExtensionWorker>;
            /**
                * Map of worker ID to the URL where it was loaded from.
                * @type {Array<string>}
                */
            workerURLs: Array<string>;
            /**
                * Responsible for determining security policies related to custom extensions.
                */
            securityManager: SecurityManager;
            /**
                * @type {VirtualMachine}
                */
            vm: VirtualMachine;
            /**
                * Whether to show a warning that extensions are officially incompatible with Scratch.
                * @type {boolean>}
                */
            showCompatibilityWarning: boolean;
            /**
                * Keep a reference to the runtime so we can construct internal extension objects.
                * @type {Runtime}
                */
            runtime: Runtime;
            loadingAsyncExtensions: number;
            asyncExtensionsLoadedCallbacks: any[];
            _customExtensionInfo: {};
            _officialExtensionInfo: {};
            builtinExtensions: {
                    coreExample: Scratch3CoreExample;
                    pen: Scratch3PenBlocks;
                    wedo2: Scratch3WeDo2Blocks;
                    microbit: Scratch3MicroBitBlocks;
                    text2speech: Scratch3Text2SpeechBlocks;
                    translate: Scratch3TranslateBlocks;
                    videoSensing: Scratch3VideoSensingBlocks;
                    ev3: Scratch3Ev3Blocks;
                    makeymakey: Scratch3MakeyMakeyBlocks;
                    boost: Scratch3BoostBlocks;
                    gdxfor: Scratch3GdxForBlocks;
                    tw: TurboWarpBlocks;
            };
            /**
                * Check whether an extension is registered or is in the process of loading. This is intended to control loading or
                * adding extensions so it may return `true` before the extension is ready to be used. Use the promise returned by
                * `loadExtensionURL` if you need to wait until the extension is truly ready.
                * @param {string} extensionID - the ID of the extension.
                * @returns {boolean} - true if loaded, false otherwise.
                */
            isExtensionLoaded(extensionID: string): boolean;
            setLoadedExtension(extensionID: any, value: any): void;
            registerExtension(extensionId: any, extension: any, shouldReplace?: boolean): any;
            /**
                * Determine whether an extension with a given ID is built in to the VM, such as pen.
                * Note that "core extensions" like motion will return false here.
                * @param {string} extensionId
                * @returns {boolean}
                */
            isBuiltinExtension(extensionId: string): boolean;
            /**
                * Get the list of external extension service URLs.
                * @returns {Array.<string>} - The list of external extension service URLs.
                */
            getGandiExternalExtensionServices(): Array<string>;
            /**
                * Set a new list of external extension service URLs.
                * This also resets the loaded flag to ensure the new services are loaded.
                * @param {Array.<string>} services - The list of new external extension service URLs.
                */
            setGandiExternalExtensionServices(services: Array<string>): void;
            /**
                * Synchronously load an internal extension (core or non-core) by ID. This call will
                * fail if the provided id is not does not match an internal extension.
                * @param {string} extensionId - the ID of an internal extension
                */
            loadExtensionIdSync(extensionId: string): any;
            addBuiltinExtension(extensionId: any, extensionClass: any): void;
            _isValidExtensionURL(extensionURL: any): boolean;
            /**
                * Load an extension by URL or internal extension ID
                * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
                * @param {bool} shouldReplace - should replace extension that already loaded
                * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
                */
            loadExtensionURL(extensionURL: string, shouldReplace?: bool): Promise<any>;
            /**
                * Loads an extension URL in a worker.
                *
                * @param {string} extensionURL - The URL of the extension to load.
                * @returns {Promise} A promise that resolves when the extension is loaded successfully, or rejects with an error if the extension is not found.
                */
            loadExtensionURLInWorker(extensionURL: string): Promise<any>;
            /**
                * Wait until all async extensions have loaded
                * @returns {Promise} resolved when all async extensions have loaded
                */
            allAsyncExtensionsLoaded(): Promise<any>;
            /**
                * Creates a new extension worker.
                * @returns {Promise}
                */
            createExtensionWorker(): Promise<any>;
            /**
                * Remove all extensions from services.
                * If we don't do so, this will cause memory leak on Single Page Application.
                */
            disposeExtensionServices(): void;
            /**
                * Regenerate blockinfo for any loaded extensions
                * @returns {Promise} resolved once all the extensions have been reinitialized
                */
            refreshBlocks(targetServiceName: any): Promise<any>;
            allocateWorker(): (string | number)[];
            /**
                * Synchronously collect extension metadata from the specified service and begin the extension registration process.
                * @param {string} serviceName - the name of the service hosting the extension.
                */
            registerExtensionServiceSync(serviceName: string): void;
            /**
                * Collect extension metadata from the specified service and begin the extension registration process.
                * @param {string} serviceName - the name of the service hosting the extension.
                */
            registerExtensionService(serviceName: string): void;
            _finishedLoadingExtensionScript(): void;
            _failedLoadingExtensionScript(error: any): void;
            /**
                * Called by an extension worker to indicate that the worker has finished initialization.
                * @param {int} id - the worker ID.
                * @param {*?} e - the error encountered during initialization, if any.
                */
            onWorkerInit(id: int, e: any | null): void;
            /**
                * Register an internal (non-Worker) extension object
                * @param {object} extensionObject - the extension object to register
                * @returns {string} The name of the registered extension service
                */
            _registerInternalExtension(extensionObject: object): string;
            /**
                * @description register gandi extension when developer load custom extension
                * @param {string} id extension id
                * @param {string} url extension url
                */
            saveWildExtensionsURL(id: string, url: string): void;
            loadExternalExtensionById(extensionId: any, shouldReplace?: boolean): Promise<any> | undefined;
            isValidExtensionURL(extensionURL: any): boolean;
            injectExtension(extensionId: any, extension: any): void;
            isExternalExtension(extensionId: any): boolean;
            clearLoadedExtensions(): void;
            addOfficialExtensionInfo(obj: any): void;
            addCustomExtensionInfo(obj: any, url: any): void;
            updateExternalExtensionConstructor(extensionId: any, func: any): void;
            getExternalExtensionConstructor(extensionId: any): Promise<any>;
            /**
                * Loads an external extension to the library.
                *
                * @param {string} url - The URL of the external extension.
                * @param {boolean} [shouldReplace=false] - Whether to replace existing extensions with the same ID.
                * @param {boolean} [disallowIIFERegister=false] - Whether to disallow registering extensions using IIFE.
                * @returns {Promise<{onlyAdded: string[], addedAndLoaded: string[]}>} - A promise that resolves with an object containing two arrays: `onlyAdded` and `addedAndLoaded`.
                * - `onlyAdded` contains the IDs of the extensions that were only added to the library.
                * - `addedAndLoaded` contains the IDs of the extensions that were both added to the library and loaded.
                * @throws {Error} - If an error occurs while loading the extension.
                */
            loadExternalExtensionToLibrary(url: string, shouldReplace?: boolean, disallowIIFERegister?: boolean): Promise<{
                    onlyAdded: string[];
                    addedAndLoaded: string[];
            }>;
            /**
                * Checks if an extension ID is reserved.
                *
                * @param {string} extensionId - The extension ID to check.
                * @returns {boolean} - Returns `false` if the extension ID is not reserved, `true` otherwise.
                */
            isExtensionIdReserved(extensionId: string): boolean;
            getLoadedExtensionURLs(): {};
            deleteExtensionById(extensionId: any): void;
            getReplaceableExtensionInfo(): any[];
            getExtensionInfoById(extensionId: any): any;
            replaceExtensionWithId(newId: any, oldId: any): void;
            isExtensionURLLoaded(extensionURL: any): boolean;
            getExtensionURLs(): {};
    }
    namespace ExtensionManager {
            export { ArgumentInfo, ConvertedBlockInfo, CategoryInfo, PendingExtensionWorker };
    }
    import SecurityManager = require("scratch-vm-dts/extension-support/tw-security-manager");
    /**
        * - Information about an extension block argument
        */
    type ArgumentInfo = {
            /**
                * - the type of value this argument can take
                */
            type: ArgumentType;
            /**
                * - the default value of this argument (default: blank)
                */
            default: any | undefined;
    };
    /**
        * - Raw extension block data paired with processed data ready for scratch-blocks
        */
    type ConvertedBlockInfo = {
            /**
                * - the raw block info
                */
            info: ExtensionBlockMetadata;
            /**
                * - the scratch-blocks JSON definition for this block
                */
            json: object;
            /**
                * - the scratch-blocks XML definition for this block
                */
            xml: string;
    };
    /**
        * - Information about a block category
        */
    type CategoryInfo = {
            /**
                * - the unique ID of this category
                */
            id: string;
            /**
                * - the human-readable name of this category
                */
            name: string;
            /**
                * - optional URI for the block icon image
                */
            blockIconURI: string | undefined;
            /**
                * - the primary color for this category, in '#rrggbb' format
                */
            color1: string;
            /**
                * - the secondary color for this category, in '#rrggbb' format
                */
            color2: string;
            /**
                * - the tertiary color for this category, in '#rrggbb' format
                */
            color3: string;
            /**
                * - the blocks, separators, etc. in this category
                */
            blocks: Array<ConvertedBlockInfo>;
            /**
                * - the menus provided by this category
                */
            menus: Array<object>;
    };
    /**
        * - Information about an extension worker still initializing
        */
    type PendingExtensionWorker = {
            /**
                * - the URL of the extension to be loaded by this worker
                */
            extensionURL: string;
            /**
                * - function to call on successful worker startup
                */
            resolve: Function;
            /**
                * - function to call on failed worker startup
                */
            reject: Function;
    };
}

declare module 'scratch-vm-dts/sprites/sprite' {
    export = Sprite;
    import Runtime from "scratch-vm-dts/engine/runtime";
    class int extends Number{}
    class Sprite {
            /**
                * Sprite to be used on the Scratch stage.
                * All clones of a sprite have shared blocks, shared costumes, shared variables,
                * shared sounds, etc.
                * @param {?Blocks} blocks Shared blocks object for all clones of sprite.
                * @param {Runtime} runtime Reference to the runtime.
                * @param {?Frames} frames Shared frames object for all clones of sprite.
                * @constructor
                */
            constructor(blocks: Blocks | null, runtime: Runtime, frames: Frames | null);
            runtime: any;
            blocks: Blocks;
            frames: Frames;
            /**
                * Human-readable name for this sprite (and all clones).
                * @type {string}
                */
            name: string;
            /**
                * List of costumes for this sprite.
                * Each entry is an object, e.g.,
                * {
                *      skinId: 1,
                *      name: "Costume Name",
                *      bitmapResolution: 2,
                *      rotationCenterX: 0,
                *      rotationCenterY: 0
                * }
                * @type {Array.<!Object>}
                */
            costumes_: Array<Object>;
            /**
                * List of sounds for this sprite.
             */
            sounds: any[];
            /**
                * List of clones for this sprite, including the original.
                * @type {Array.<!RenderedTarget>}
                */
            clones: Array<RenderedTarget>;
            soundBank: any;
            /**
                * Add an array of costumes, taking care to avoid duplicate names.
                * @param {!Array<object>} costumes Array of objects representing costumes.
                */
            set costumes(costumes: Array<object>);
            /**
                * Get full costume list
                * @return {object[]} list of costumes. Note that mutating the returned list will not
                *     mutate the list on the sprite. The sprite list should be mutated by calling
                *     addCostumeAt, deleteCostumeAt, or setting costumes.
                */
            get costumes(): object[];
            /**
                * Add a costume at the given index, taking care to avoid duplicate names.
                * @param {!object} costumeObject Object representing the costume.
                * @param {!int} index Index at which to add costume
                */
            addCostumeAt(costumeObject: object, index: int): void;
            /**
                * Delete a costume by index.
                * @param {number} index Costume index to be deleted
                * @return {?object} The deleted costume
                */
            deleteCostumeAt(index: number): object | null;
            /**
                * Create a clone of this sprite.
                * @param {string=} optLayerGroup Optional layer group the clone's drawable should be added to
                * Defaults to the sprite layer group
                * @returns {!RenderedTarget} Newly created clone.
                */
            createClone(optLayerGroup?: string | undefined): RenderedTarget;
            /**
                * Disconnect a clone from this sprite. The clone is unmodified.
                * In particular, the clone's dispose() method is not called.
                * @param {!RenderedTarget} clone - the clone to be removed.
                */
            removeClone(clone: RenderedTarget): void;
            cloneCount(): number;
            duplicate(): Promise<Sprite>;
            dispose(): void;
    }
    import Blocks = require("scratch-vm-dts/engine/blocks");
    import Frames = require("scratch-vm-dts/engine/frame");
    import RenderedTarget = require("scratch-vm-dts/sprites/rendered-target");
}

declare module 'scratch-vm-dts/sprites/rendered-target' {
    export = RenderedTarget;
    import Runtime from "scratch-vm-dts/engine/runtime";
    import Sprite from 'scratch-vm-dts/sprites/sprite';
    class RenderWebGL{}
    class int extends Number{}
    /**
        * Rendered target: instance of a sprite (clone), or the stage.
        */
    class RenderedTarget extends Target {
            /**
                * Rotation style for "all around"/spinning.
                * @type {string}
                */
            static get ROTATION_STYLE_ALL_AROUND(): string;
            /**
                * Rotation style for "left-right"/flipping.
                * @type {string}
                */
            static get ROTATION_STYLE_LEFT_RIGHT(): string;
            /**
                * Rotation style for "no rotation."
                * @type {string}
                */
            static get ROTATION_STYLE_NONE(): string;
            /**
                * Available states for video input.
                * @enum {string}
                */
            static get VIDEO_STATE(): {
                    OFF: string;
                    ON: string;
                    ON_FLIPPED: string;
            };
            /**
                * @param {!Sprite} sprite Reference to the parent sprite.
                * @param {Runtime} runtime Reference to the runtime.
                * @constructor
                */
            constructor(sprite: Sprite, runtime: Runtime);
            /**
                * Reference to the sprite that this is a render of.
                * @type {!Sprite}
                */
            sprite: Sprite;
            /**
                * Reference to the global renderer for this VM, if one exists.
                * @type {?RenderWebGL}
                */
            renderer: RenderWebGL | null;
            /**
                * ID of the drawable for this rendered target,
                * returned by the renderer, if rendered.
                * @type {?Number}
                */
            drawableID: number | null;
            /**
                * Drag state of this rendered target. If true, x/y position can't be
                * changed by blocks.
                * @type {boolean}
                */
            dragging: boolean;
            /**
                * Map of current graphic effect values.
                * @type {!Object.<string, number>}
                */
            effects: {
                    [x: string]: number;
            };
            /**
                * Whether this represents an "original" non-clone rendered-target for a sprite,
                * i.e., created by the editor and not clone blocks.
                * @type {boolean}
                */
            isOriginal: boolean;
            /**
                * Whether this rendered target represents the Scratch stage.
                * @type {boolean}
                */
            isStage: boolean;
            /**
             * Scratch X coordinate. Currently should range from -240 to 240.
             * @type {Number}
             */
            _x: number;
            /**
             * Scratch Y coordinate. Currently should range from -180 to 180.
             * @type {number}
             */
            _y: number;
            /**
                * Scratch direction. Currently should range from -179 to 180.
                * @type {number}
                */
            direction: number;
            /**
                * Whether the rendered target is draggable on the stage
                * @type {boolean}
                */
            draggable: boolean;
            /**
             * Whether the rendered target is currently visible.
             * @type {boolean}
             */
            _visible: boolean;
            /**
             * Size of rendered target as a percent of costume size.
             * @type {number}
             */
            _size: number;
            /**
                * Non-uniform scale dimensions of rendered target as a percent of original size.
                */
            _size2d: number[];
            /**
                * Currently selected costume index.
                * @type {number}
                */
            currentCostume: number;
            /**
                * Current rotation style.
                * @type {!string}
                */
            rotationStyle: string;
            /**
                * Loudness for sound playback for this target, as a percentage.
                * @type {number}
                */
            volume: number;
            /**
                * Current tempo (used by the music extension).
                * This property is global to the project and stored in the stage.
                * @type {number}
                */
            tempo: number;
            /**
                * The transparency of the video (used by extensions with camera input).
                * This property is global to the project and stored in the stage.
                * @type {number}
                */
            videoTransparency: number;
            /**
                * The state of the video input (used by extensions with camera input).
                * This property is global to the project and stored in the stage.
                *
                * Defaults to ON. This setting does not turn the video by itself. A
                * video extension once loaded will set the video device to this
                * setting. Set to ON when a video extension is added in the editor the
                * video will start ON. If the extension is loaded as part of loading a
                * saved project the extension will see the value set when the stage
                * was loaded from the saved values including the video state.
                *
                * @type {string}
                */
            videoState: string;
            /**
                * The language to use for speech synthesis, in the text2speech extension.
                * It is initialized to null so that on extension load, we can check for
                * this and try setting it using the editor locale.
                * @type {string}
                */
            textToSpeechLanguage: string;
            onTargetMoved: any;
            onTargetVisualChange: any;
            interpolationData: any;
            extractProperties: {};
            isModule: any;
            set size(size: number);
            get size(): number;
            set size2d([width, height]: number[]);
            get size2d(): number[];
            set visible(visible: boolean);
            get visible(): boolean;
            set x(x: number);
            get x(): number;
            set y(y: number);
            get y(): number;
            get originalTargetId(): any;
            /**
                * Create a drawable with the this.renderer.
                * @param {boolean} layerGroup The layer group this drawable should be added to
                */
            initDrawable(layerGroup: boolean): void;
            get audioPlayer(): {
                    playSound: (soundId: any) => any;
            };
            /**
                * Initialize the audio player for this sprite or clone.
                */
            initAudio(): void;
            emitVisualChange(): void;
            /**
                * Set the X and Y coordinates.
                * @param {!number} x New X coordinate, in Scratch coordinates.
                * @param {!number} y New Y coordinate, in Scratch coordinates.
                * @param {?boolean} force Force setting X/Y, in case of dragging
                */
            setXY(x: number, y: number, force: boolean | null): void;
            /**
                * Get the rendered direction and scale, after applying rotation style.
                * @return {object<string, number>} Direction and scale to render.
                */
            _getRenderedDirectionAndScale(): object;
            /**
                * Set the direction.
                * @param {!number} direction New direction.
                */
            setDirection(direction: number): void;
            /**
                * Set draggability; i.e., whether it's able to be dragged in the player
                * @param {!boolean} draggable True if should be draggable.
                */
            setDraggable(draggable: boolean): void;
            /**
                * Set visibility; i.e., whether it's shown or hidden.
                * @param {!boolean} visible True if should be shown.
                */
            setVisible(visible: boolean): void;
            /**
                * Set size, as a percentage of the costume size.
                * @param {!number} size Size of rendered target, as % of costume size.
                */
            setSize(size: number): void;
            /**
                * Set a particular graphic effect value.
                * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
                * @param {!number} value Numerical magnitude of effect.
                */
            setEffect(effectName: string, value: number): void;
            /**
                * Clear all graphic effects on this rendered target.
                */
            clearEffects(): void;
            /**
                * Set the current costume.
                * @param {number} index New index of costume.
                */
            setCostume(index: number): void;
            /**
                * Add a costume, taking care to avoid duplicate names.
                * @param {!object} costumeObject Object representing the costume.
                * @param {?int} index Index at which to add costume
                * @param {?boolean} isRemoteOperation Whether this is a remote operation
                */
            addCostume(costumeObject: object, index: int | null, isRemoteOperation: boolean | null): void;
            /**
                * Rename a costume, taking care to avoid duplicate names.
                * @param {int} costumeIndex - the index of the costume to be renamed.
                * @param {string} newName - the desired new name of the costume (will be modified if already in use).
                * @param {boolean} [sendNameChangedEvent = true] whether to send an event when the name changes.
                */
            renameCostume(costumeIndex: int, newName: string, sendNameChangedEvent?: boolean): void;
            /**
                * Delete a costume by index.
                * @param {number} index Costume index to be deleted
                * @param {?boolean} isRemoteOperation Whether this is a remote operation
                * @return {?object} The costume that was deleted or null
                * if the index was out of bounds of the costumes list or
                * this target only has one costume.
                */
            deleteCostume(index: number, isRemoteOperation: boolean | null): object | null;
            /**
                * Add a sound, taking care to avoid duplicate names.
                * @param {!object} soundObject Object representing the sound.
                * @param {?int} index Index at which to add costume
                */
            addSound(soundObject: object, index: int | null): void;
            /**
                * Rename a sound, taking care to avoid duplicate names.
                * @param {int} soundIndex - the index of the sound to be renamed.
                * @param {string} newName - the desired new name of the sound (will be modified if already in use).
                * @param {boolean} [sendNameChangedEvent = true] whether to send an event when the name changes.
                * @return {string} The new name of the sound.
                */
            renameSound(soundIndex: int, newName: string, sendNameChangedEvent?: boolean): string;
            /**
                * Delete a sound by index.
                * @param {number} index Sound index to be deleted
                * @return {object} The deleted sound object, or null if no sound was deleted.
                */
            deleteSound(index: number): object;
            /**
                * Update the rotation style.
                * @param {!string} rotationStyle New rotation style.
                */
            setRotationStyle(rotationStyle: string): void;
            /**
                * Get a costume index of this rendered target, by name of the costume.
                * @param {?string} costumeName Name of a costume.
                * @return {number} Index of the named costume, or -1 if not present.
                */
            getCostumeIndexByName(costumeName: string | null): number;
            /**
                * Get a costume index of this rendered target, by id of the costume.
                * @param {?string} costumeId Id of a costume.
                * @return {number} Index of the named costume, or -1 if not present.
                */
            getCostumeIndexById(costumeId: string | null): number;
            getCostumeById(id: any): object | null;
            /**
                * Get a costume of this rendered target by id.
                * @return {object} current costume
                */
            getCurrentCostume(): object;
            /**
                * Get full costume list
                * @return {object[]} list of costumes
                */
            getCostumes(): object[];
            /**
                * Reorder costume list by moving costume at costumeIndex to newIndex.
                * @param {!number} costumeIndex Index of the costume to move.
                * @param {!number} newIndex New index for that costume.
                * @returns {boolean} If a change occurred (i.e. if the indices do not match)
                */
            reorderCostume(costumeIndex: number, newIndex: number): boolean;
            /**
                * Reorder sound list by moving sound at soundIndex to newIndex.
                * @param {!number} soundIndex Index of the sound to move.
                * @param {!number} newIndex New index for that sound.
                * @returns {boolean} If a change occurred (i.e. if the indices do not match)
                */
            reorderSound(soundIndex: number, newIndex: number): boolean;
            /**
                * Get full sound list
                * @return {object[]} list of sounds
                */
            getSounds(): object[];
            /**
                * Get a sound index of this rendered target, by id of the sound.
                * @param {?string} soundId Id of a sound.
                * @return {number} Index of the named sound, or -1 if not present.
                */
            getSoundIndexById(soundId: string | null): number;
            getSoundById(id: any): object | null;
            /**
                * Update all drawable properties for this rendered target.
                * Use when a batch has changed, e.g., when the drawable is first created.
                */
            updateAllDrawableProperties(): void;
            /**
                * Return whether this rendered target is a sprite (not a clone, not the stage).
                * @return {boolean} True if not a clone and not the stage.
                */
            isSprite(): boolean;
            /**
                * Return the rendered target's tight bounding box.
                * Includes top, left, bottom, right attributes in Scratch coordinates.
                * @return {?object} Tight bounding box, or null.
                */
            getBounds(): object | null;
            /**
                * Return the bounding box around a slice of the top 8px of the rendered target.
                * Includes top, left, bottom, right attributes in Scratch coordinates.
                * @return {?object} Tight bounding box, or null.
                */
            getBoundsForBubble(): object | null;
            /**
                * Return whether this target is touching the mouse, an edge, or a sprite.
                * @param {string} requestedObject an id for mouse or edge, or a sprite name.
                * @return {boolean} True if the sprite is touching the object.
                */
            isTouchingObject(requestedObject: string): boolean;
            /**
                * Return whether touching a point.
                * @param {number} x X coordinate of test point.
                * @param {number} y Y coordinate of test point.
                * @return {boolean} True iff the rendered target is touching the point.
                */
            isTouchingPoint(x: number, y: number): boolean;
            /**
                * Return whether touching a stage edge.
                * @return {boolean} True iff the rendered target is touching the stage edge.
                */
            isTouchingEdge(): boolean;
            /**
                * Return whether touching any of a named sprite's clones.
                * @param {string} spriteName Name of the sprite.
                * @return {boolean} True iff touching a clone of the sprite.
                */
            isTouchingSprite(spriteName: string): boolean;
            /**
                * Return whether touching a color.
                * @param {Array.<number>} rgb [r,g,b], values between 0-255.
                * @return {Promise.<boolean>} True iff the rendered target is touching the color.
                */
            isTouchingColor(rgb: Array<number>): Promise<boolean>;
            /**
                * Return whether rendered target's color is touching a color.
                * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
                * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
                * @return {Promise.<boolean>} True iff the color is touching the color.
                */
            colorIsTouchingColor(targetRgb: object, maskRgb: object): Promise<boolean>;
            getLayerOrder(): any;
            /**
                * Move to the front layer.
                */
            goToFront(): void;
            /**
                * Move to the back layer.
                */
            goToBack(): void;
            /**
                * Move forward a number of layers.
                * @param {number} nLayers How many layers to go forward.
                */
            goForwardLayers(nLayers: number): void;
            /**
                * Move backward a number of layers.
                * @param {number} nLayers How many layers to go backward.
                */
            goBackwardLayers(nLayers: number): void;
            /**
                * Move behind some other rendered target.
                * @param {!RenderedTarget} other Other rendered target to move behind.
                */
            goBehindOther(other: RenderedTarget): void;
            /**
                * Keep a desired position within a fence.
                * @param {number} newX New desired X position.
                * @param {number} newY New desired Y position.
                * @param {object=} optFence Optional fence with left, right, top bottom.
                * @return {Array.<number>} Fenced X and Y coordinates.
                */
            keepInFence(newX: number, newY: number, optFence?: object | undefined): Array<number>;
            /**
                * Make a clone, copying any run-time properties.
                * If we've hit the global clone limit, returns null.
                * @return {RenderedTarget} New clone.
                */
            makeClone(): RenderedTarget;
            /**
                * Make a duplicate using a duplicate sprite.
                * @return {RenderedTarget} New clone.
                */
            duplicate(): RenderedTarget;
            /**
                * Called when the project receives a "stop all"
                * Stop all sounds and clear graphic effects.
                */
            onStopAll(): void;
            /**
                * Post/edit sprite info.
                * @param {object} data An object with sprite info data to set.
                */
            postSpriteInfo(data: object): void;
            /**
                * Put the sprite into the drag state. While in effect, setXY must be forced
                */
            startDrag(): void;
            /**
                * Remove the sprite from the drag state.
                */
            stopDrag(): void;
            /**
                * Serialize sprite info, used when emitting events about the sprite
                * @returns {object} Sprite data as a simple object
                */
            toJSON(): object;
    }
    import Target = require("scratch-vm-dts/engine/target");
}

declare module 'scratch-vm-dts/engine/blocks' {
    export = Blocks;
    import Target from './target'
    /**
        * Create a block container.
        * @param {Runtime} runtime The runtime this block container operates within
        * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container
        * should not request glows. This does not affect glows when clicking on a block to execute it.
        */
    class Blocks {
            /**
                * Blockly inputs that represent statements/branch.
                * are prefixed with this string.
                * @const{string}
                */
            static get BRANCH_INPUT_PREFIX(): string;
            constructor(runtime: any, optNoGlow: any);
            runtime: any;
            /**
                * All blocks in the workspace.
                * Keys are block IDs, values are metadata about the block.
                * @type {Object.<string, Object>}
                */
            _blocks: {
                    [x: string]: Object;
            };
            /**
                * All top-level scripts in the workspace.
                * A list of block IDs that represent scripts (i.e., first block in script).
                * @type {Array.<String>}
                */
            _scripts: Array<string>;
            _cache: {
                    /**
                        * Cache block inputs by block id
                        * @type {object.<string, !Array.<object>>}
                        */
                    inputs: {[key:string]:Array<object>};
                    /**
                        * Cache procedure Param Names by block id
                        * @type {object.<string, ?Array.<string>>}
                        */
                    procedureParamNames: {[key:string]:Array<string>};
                    /**
                        * Cache procedure definitions by block id
                        * @type {object.<string, ?string>}
                        */
                    procedureDefinitions: {[key:string]:string|null};
                    /**
                        * A cache for execute to use and store on. Only available to
                        * execute.
                        * @type {object.<string, object>}
                        */
                    _executeCached: {[key:string]:object};
                    /**
                        * A cache of block IDs and targets to start threads on as they are
                        * actively monitored.
                        * @type {Array<{blockId: string, target: Target}>}
                        */
                    _monitored: Array<{
                            blockId: string;
                            target: Target;
                    }>;
                    /**
                        * A cache of hat opcodes to collection of theads to execute.
                        * @type {object.<string, object>}
                        */
                    scripts: {[key:string]:object};
                    /**
                        * tw: A cache of top block (usually hat, but not always) opcodes to compiled scripts.
                        * @type {object.<string, object>}
                        */
                    compiledScripts: {[key:string]:object};
                    /**
                        * tw: A cache of procedure code opcodes to a parsed intermediate representation
                        * @type {object.<string, object>}
                        */
                    compiledProcedures: {[key:string]:object};
                    /**
                        * tw: Whether populateProcedureCache has been run
                        */
                    proceduresPopulated: boolean;
            };
            /**
                * Flag which indicates that blocks in this container should not glow.
                * Blocks will still glow when clicked on, but this flag is used to control
                * whether the blocks in this container can request a glow as part of
                * a running stack. E.g. the flyout block container and the monitor block container
                * should not be able to request a glow, but blocks containers belonging to
                * sprites should.
                * @type {boolean}
                */
            forceNoGlow: boolean;
            /**
                * Get the cached compilation result of a block.
                * @param {string} blockId ID of the top block.
                * @returns {{success: boolean; value: any}|null} Cached success or error, or null if there is no cached value.
                */
            getCachedCompileResult(blockId: string): {
                    success: boolean;
                    value: any;
            } | null;
            /**
                * Set the cached compilation result of a script.
                * @param {string} blockId ID of the top block.
                * @param {*} value The compilation result to store.
                */
            cacheCompileResult(blockId: string, value: any): void;
            /**
                * Set the cached error of a script.
                * @param {string} blockId ID of the top block.
                * @param {*} error The error to store.
                */
            cacheCompileError(blockId: string, error: any): void;
            /**
                * Provide an object with metadata for the requested block ID.
                * @param {!string} blockId ID of block we have stored.
                * @return {?object} Metadata about the block, if it exists.
                */
            getBlock(blockId: string): object | null;
            /**
                * Get all known top-level blocks that start scripts.
                * @return {Array.<string>} List of block IDs.
                */
            getScripts(): Array<string>;
            /**
                 * Get the next block for a particular block
                 * @param {?string} id ID of block to get the next block for
                 * @return {?string} ID of next block in the sequence
                 */
            getNextBlock(id: string | null): string | null;
            /**
                * Get the branch for a particular C-shaped block.
                * @param {?string} id ID for block to get the branch for.
                * @param {?number} branchNum Which branch to select (e.g. for if-else).
                * @return {?string} ID of block in the branch.
                */
            getBranch(id: string | null, branchNum: number | null): string | null;
            /**
                * Get the opcode for a particular block
                * @param {?object} block The block to query
                * @return {?string} the opcode corresponding to that block
                */
            getOpcode(block: object | null): string | null;
            /**
                * Get all fields and their values for a block.
                * @param {?object} block The block to query.
                * @return {?object} All fields and their values.
                */
            getFields(block: object | null): object | null;
            /**
                * Get all non-branch inputs for a block.
                * @param {?object} block the block to query.
                * @return {?Array.<object>} All non-branch inputs and their associated blocks.
                */
            getInputs(block: object | null): Array<object> | null;
            /**
                * Get mutation data for a block.
                * @param {?object} block The block to query.
                * @return {?object} Mutation for the block.
                */
            getMutation(block: object | null): object | null;
            /**
                * Get the top-level script for a given block.
                * @param {?string} id ID of block to query.
                * @return {?string} ID of top-level script block.
                */
            getTopLevelScript(id: string | null): string | null;
            getGlobalProceduresXML(): string[];
            /**
                * Get the procedure definition for a given name.
                * @param {?string} name Name of procedure to query.
                * @return {?string} ID of procedure definition.
                */
            getProcedureDefinition(name: string | null): string | null;
            getGlobalProcedureAndTarget(name: any): any[];
            /**
                * Get names and ids of parameters for the given procedure.
                * @param {?string} name Name of procedure to query.
                * @return {?Array.<string>} List of param names for a procedure.
                */
            getProcedureParamNamesAndIds(name: string | null): Array<string> | null;
            /**
                * Get names, ids, and defaults of parameters for the given procedure.
                * @param {?string} name Name of procedure to query.
                * @return {?Array.<string>} List of param names for a procedure.
                */
            _getProcedureParamNamesIdsAndDefaults(name: string | null): Array<string> | null;
            /** CCW: for global procedure
                * Get names, ids, and defaults of parameters for the given procedure.
                * @param {?string} name Name of procedure to query.
                * @param {?boolean} isGlobal need look up procedures from all runtime targets
                * @return {?Array.<any>} List of param names for a procedure.
                */
            getProcedureParamNamesIdsAndDefaults(name: string | null, isGlobal: boolean | null): Array<any> | null;
            /**
                * tw: Setup the procedureParamNames and procedureDefinitions caches all at once.
                * This makes subsequent calls to these methods faster.
                */
            populateProcedureCache(): void;
            updateGlobalProcedure(oldProccode: any, newMutation: any): any[];
            duplicate(): Blocks;
            /**
                * Create event listener for blocks, variables, and comments. Handles validation and
                * serves as a generic adapter between the blocks, variables, and the
                * runtime interface.
                * @param {object} e Blockly "block" or "variable" event
                * @param {string} source Who triggered this function
                */
            blocklyListen(e: object, source: string): void;
            /**
                * Reset all runtime caches.
                */
            resetCache(): void;
            /**
                * Emit a project changed event if this is a block container
                * that can affect the project state.
                */
            emitProjectChanged(): void;
            emitCustomBlockArgumentsLengthChanged(): void;
            /**
                * Block management: create blocks and scripts from a `create` event
                * @param {!object} block Blockly create event to be processed
                * @return {boolean} Whether the block successfully created
                */
            createBlock(block: object, source: any): boolean;
            /**
                * Block management: change block field values
                * @param {!object} args Blockly change event to be processed
                * @param {boolean} isRuntimeOp Whether it is an operation at run time
                */
            changeBlock(args: object, isRuntimeOp: boolean): void;
            updateBlockMutation(block: any, args: any): void;
            /**
                * Block management: move blocks from parent to parent
                * @param {!object} e Blockly move event to be processed
                */
            moveBlock(e: object): void;
            /**
                * Block management: run all blocks.
                * @param {!object} runtime Runtime to run all blocks in.
                */
            runAllMonitored(runtime: object): void;
            /**
                * Block management: delete blocks and their associated scripts. Does nothing if a block
                * with the given ID does not exist.
                * @param {!string} blockId Id of block to delete
                */
            deleteBlock(blockId: string, params?: {}): void;
            /**
                * Delete all blocks and their associated scripts.
                */
            deleteAllBlocks(): void;
            /**
                * Returns a map of all references to variables or lists from blocks
                * in this block container.
                * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.
                * This is useful for getting variable/list references for a stack of blocks instead
                * of all blocks on the workspace
                * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.
                * @return {object} A map of variable ID to a list of all variable references
                * for that ID. A variable reference contains the field referencing that variable
                * and also the type of the variable being referenced.
                */
            getAllVariableAndListReferences(optBlocks: Array<object>, optIncludeBroadcast: boolean | null): object;
            getAllVariableAndListWithBlocks(blocks: any, optIncludeBroadcast: any): any[][];
            /**
                * Keep blocks up to date after a variable gets renamed.
                * @param {string} varId The id of the variable that was renamed
                * @param {string} newName The new name of the variable that was renamed
                */
            updateBlocksAfterVarRename(varId: string, newName: string): any[][];
            /**
                * Keep blocks up to date after they are shared between targets.
                * @param {boolean} isStage If the new target is a stage.
                */
            updateTargetSpecificBlocks(isStage: boolean): void;
            /**
                * Update blocks after a sound, costume, or backdrop gets renamed.
                * Any block referring to the old name of the asset should get updated
                * to refer to the new name.
                * @param {string} oldName The old name of the asset that was renamed.
                * @param {string} newName The new name of the asset that was renamed.
                * @param {string} assetType String representation of the kind of asset
                * @param {?string} targetId The ID of the target to emit block changes for (optional).
                * that was renamed. This can be one of 'sprite','costume', 'sound', or
                * 'backdrop'.
                */
            updateAssetName(oldName: string, newName: string, assetType: string, targetId: string | null): void;
            /**
                * Update sensing_of blocks after a variable gets renamed.
                * @param {string} oldName The old name of the variable that was renamed.
                * @param {string} newName The new name of the variable that was renamed.
                * @param {string} targetName The name of the target the variable belongs to.
                * @return {boolean} Returns true if any of the blocks were updated.
                */
            updateSensingOfReference(oldName: string, newName: string, targetName: string): boolean;
            /**
                * Helper function to retrieve a costume menu field from a block given its id.
                * @param {string} blockId A unique identifier for a block
                * @return {?object} The costume menu field of the block with the given block id.
                * Null if either a block with the given id doesn't exist or if a costume menu field
                * does not exist on the block with the given id.
                */
            _getCostumeField(blockId: string): object | null;
            /**
                * Helper function to retrieve a sound menu field from a block given its id.
                * @param {string} blockId A unique identifier for a block
                * @return {?object} The sound menu field of the block with the given block id.
                * Null, if either a block with the given id doesn't exist or if a sound menu field
                * does not exist on the block with the given id.
                */
            _getSoundField(blockId: string): object | null;
            /**
                * Helper function to retrieve a backdrop menu field from a block given its id.
                * @param {string} blockId A unique identifier for a block
                * @return {?object} The backdrop menu field of the block with the given block id.
                * Null, if either a block with the given id doesn't exist or if a backdrop menu field
                * does not exist on the block with the given id.
                */
            _getBackdropField(blockId: string): object | null;
            /**
                * Helper function to retrieve a sprite menu field from a block given its id.
                * @param {string} blockId A unique identifier for a block
                * @return {?object} The sprite menu field of the block with the given block id.
                * Null, if either a block with the given id doesn't exist or if a sprite menu field
                * does not exist on the block with the given id.
                */
            _getSpriteField(blockId: string): object | null;
            /**
                * Encode all of `this._blocks` as an XML string usable
                * by a Blockly/scratch-blocks workspace.
                * @param {object<string, Comment>} comments Map of comments referenced by id
                * @return {string} String of XML representing this object's blocks.
                */
            toXML(comments: any): string;
            /**
                * Recursively encode an individual block and its children
                * into a Blockly/scratch-blocks XML string.
                * @param {!string} blockId ID of block to encode.
                * @param {object<string, Comment>} comments Map of comments referenced by id
                * @return {string} String of XML representing this block and any children.
                */
            blockToXML(blockId: string, comments: any, blocks?: {
                    [x: string]: Object;
            }): string;
            /**
                * Recursively encode a mutation object to XML.
                * @param {!object} mutation Object representing a mutation.
                * @return {string} XML string representing a mutation.
                */
            mutationToXML(mutation: object): string;
            /**
                * Helper to serialize block fields and input fields for reporting new monitors
                * @param {!object} block Block to be paramified.
                * @return {!object} object of param key/values.
                */
            _getBlockParams(block: object): object;
            /**
                * Helper to get the corresponding internal procedure definition block
                * @param {!object} defineBlock Outer define block.
                * @return {!object} internal definition block which has the mutation.
                */
            _getCustomBlockInternal(defineBlock: object): object;
            /**
                * Helper to add a stack to `this._scripts`.
                * @param {?string} topBlockId ID of block that starts the script.
                * @return {boolean} Whether added successfully.
                */
            _addScript(topBlockId: string | null): boolean;
            /**
                * Helper to remove a script from `this._scripts`.
                * @param {?string} topBlockId ID of block that starts the script.
                */
            _deleteScript(topBlockId: string | null): void;
    }
}

declare module 'scratch-vm-dts/engine/frame' {
    export = Frames;
    /**
        * Create a frame container.
        * @param {Runtime} runtime The runtime this frame container operates within
        */
    class Frames {
            constructor(runtime: any);
            runtime: any;
            /**
                * All frames in the workspace.
                * Keys are frame IDs, values are metadata about the frame.
                * @type {Object.<string, Object>}
                */
            _frames: {
                    [x: string]: Object;
            };
            /**
                * Provide an object with metadata for the requested frame ID.
                * @param {!string} frameId ID of frame we have stored.
                * @return {?object} Metadata about the frame, if it exists.
                */
            getFrame(frameId: string): object | null;
            duplicate(): Frames;
            /**
                * Create event listener for frames. Handles validation and
                * serves as a generic adapter between the frames, variables, and the
                * runtime interface.
                * @param {object} e Blockly "frame" event
                */
            blocklyListen(e: object): void;
            /**
                * Emit a project changed event
                * that can affect the project state.
                */
            emitProjectChanged(): void;
            /**
                * Frame management: create frames from a `create` event
                * @param {!object} e Blockly create event to be processed
                */
            createFrame(e: object): boolean;
            /**
                * Frame management: delete frame. Does nothing if a frame with the given ID does not exist.
                * @param {!string} id Id of frame to delete
                */
            deleteFrame(id: string): boolean;
            /**
                * Frame management: delete frame. Does nothing if a frame with the given ID does not exist.
                * @param {!string} id Id of frame to delete
                * @param {!string} newTitle New title
                */
            retitleFrame(id: string, newTitle: string): boolean;
            /**
                * Frame management: change frame field values
                * @param {!string} id Id of the frame
                * @param {string} element One of 'rect', 'blocks', 'disabled', etc.
                * @param {*} value Previous value of element.
                */
            changeFrame(id: string, element: string, value: any): boolean;
            /**
                * Recursively encode an individual frame into a Blockly/scratch-block XML string.
                * @param {!string} id ID of frame to encode.
                * @return {string} String of XML representing this frame.
                */
            toXML(id: string): string;
            frameToXML(frame: any): string;
    }
}

declare module 'scratch-vm-dts/engine/variable' {
    export = Variable;
    class Variable {
            /**
                * Type representation for scalar variables.
                * This is currently represented as ''
                * for compatibility with blockly.
                * @const {string}
                */
            static get SCALAR_TYPE(): string;
            /**
                * Type representation for list variables.
                * @const {string}
                */
            static get LIST_TYPE(): string;
            /**
                * Type representation for list variables.
                * @const {string}
                */
            static get BROADCAST_MESSAGE_TYPE(): string;
            /**
                * @param {string} id Id of the variable.
                * @param {string} name Name of the variable.
                * @param {string} type Type of the variable, one of '' or 'list'
                * @param {boolean} isCloud Whether the variable is stored in the cloud.
                * @constructor
                */
            constructor(id: string, name: string, type: string, isCloud: boolean, targetId: any);
            id: string;
            name: string;
            type: string;
            isCloud: boolean;
            targetId: any;
            value: string | number | any[];
            toXML(isLocal: any): string;
    }
}

declare module 'scratch-vm-dts/util/timer' {
    export = Timer;
    /**
        * @fileoverview
        * A utility for accurately measuring time.
        * To use:
        * ---
        * var timer = new Timer();
        * timer.start();
        * ... pass some time ...
        * var timeDifference = timer.timeElapsed();
        * ---
        * Or, you can use the `time` function
        * to do some measurement yourself.
        */
    class Timer {
            /**
                * Disable use of self.performance for now as it results in lower performance
                * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
                * @type {boolean}
                */
            static get USE_PERFORMANCE(): boolean;
            /**
                * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
                * @deprecated This is only called via the nowObj.now() if no other means is possible...
                */
            static get legacyDateCode(): {
                    now: () => number;
            };
            /**
                * Use this object to route all time functions through single access points.
                */
            static get nowObj(): {
                    now: () => number;
            };
            constructor(nowObj?: {
                    now: () => number;
            });
            /**
                * Used to store the start time of a timer action.
                * Updated when calling `timer.start`.
                */
            startTime: number;
            /**
                * Used to pass custom logic for determining the value for "now",
                * which is sometimes useful for compatibility with Scratch 2
                */
            nowObj: {
                    now: () => number;
            };
            /**
                * Return the currently known absolute time, in ms precision.
                * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
                */
            time(): number;
            /**
                * Start a timer for measuring elapsed time,
                * at the most accurate precision possible.
                */
            start(): void;
            timeElapsed(): number;
            /**
                * Call a handler function after a specified amount of time has elapsed.
                * @param {function} handler - function to call after the timeout
                * @param {number} timeout - number of milliseconds to delay before calling the handler
                * @returns {number} - the ID of the new timeout
                */
            setTimeout(handler: Function, timeout: number): number;
            /**
                * Clear a timeout from the pending timeout pool.
                * @param {number} timeoutId - the ID returned by `setTimeout()`
                * @memberof Timer
                */
            clearTimeout(timeoutId: number): void;
    }
}

declare module 'scratch-vm-dts/engine/thread' {
    export = Thread;
    import Target from './target'
    import Blocks from 'scratch-vm-dts/engine/blocks';
    import Timer from 'scratch-vm-dts/util/timer';
    /**
        * A thread is a running stack context and all the metadata needed.
        * @param {?string} firstBlock First block to execute in the thread.
        * @constructor
        */
    class Thread {
            /**
                * Thread status for initialized or running thread.
                * This is the default state for a thread - execution should run normally,
                * stepping from block to block.
                * @const
                */
            static get STATUS_RUNNING(): number;
            /**
                * Threads are in this state when a primitive is waiting on a promise;
                * execution is paused until the promise changes thread status.
                * @const
                */
            static get STATUS_PROMISE_WAIT(): number;
            /**
                * Thread status for yield.
                * @const
                */
            static get STATUS_YIELD(): number;
            /**
                * Thread status for a single-tick yield. This will be cleared when the
                * thread is resumed.
                * @const
                */
            static get STATUS_YIELD_TICK(): number;
            /**
                * Thread status for a finished/done thread.
                * Thread is in this state when there are no more blocks to execute.
                * @const
                */
            static get STATUS_DONE(): number;
            /**
                * @param {Target} target The target running the thread.
                * @param {string} topBlock ID of the thread's top block.
                * @returns {string} A unique ID for this target and thread.
                */
            static getIdFromTargetAndBlock(target: Target, topBlock: string): string;
            constructor(firstBlock: any);
            /**
                * ID of top block of the thread
                * @type {!string}
                */
            topBlock: string;
            /**
                * Stack for the thread. When the sequencer enters a control structure,
                * the block is pushed onto the stack so we know where to exit.
                * @type {Array.<string>}
                */
            stack: Array<string>;
            /**
                * Stack frames for the thread. Store metadata for the executing blocks.
                * @type {Array.<_StackFrame>}
                */
            stackFrames: Array<_StackFrame>;
            /**
                * Status of the thread, one of three states (below)
                * @type {number}
                */
            status: number;
            /**
                * Whether the thread is killed in the middle of execution.
                * @type {boolean}
                */
            isKilled: boolean;
            /**
                * Target of this thread.
                * @type {?Target}
                */
            target: Target | null;
            /**
                * The Blocks this thread will execute.
                * @type {Blocks}
                */
            blockContainer: Blocks;
            /**
                * Whether the thread requests its script to glow during this frame.
                * @type {boolean}
                */
            requestScriptGlowInFrame: boolean;
            /**
                * Which block ID should glow during this frame, if any.
                * @type {?string}
                */
            blockGlowInFrame: string | null;
            /**
                * A timer for when the thread enters warp mode.
                * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.
                * @type {?Timer}
                */
            warpTimer: Timer | null;
            justReported: any;
            triedToCompile: boolean;
            isCompiled: boolean;
            timer: any;
            /**
                * The thread's generator.
                * @type {Generator}
                */
            generator: Generator;
            /**
                * @type {Object.<string, import('../compiler/compile').CompiledScript>}
                */
            procedures: {
                    [x: string]: any;
            };
            stackClick: boolean;
            updateMonitor: boolean;
            /**
                * store hat param.
                * @type {Object}
                */
            hatParam: Object;
            executableHat: boolean;
            compatibilityStackFrame: any;
            getId(): string;
            getCurrentGlobalTarget(): any;
            /**
                * Push stack and update stack frames appropriately.
                * @param {string} blockId Block ID to push to stack.
                * @param {Target} target CCW: the target execute in this stack frame, for global procedure.
                */
            pushStack(blockId: string, target: Target): void;
            /**
                * Reset the stack frame for use by the next block.
                * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same
                * @param {string} blockId Block ID to push to stack.
                */
            reuseStackForNextBlock(blockId: string): void;
            /**
                * Pop last block on the stack and its stack frame.
                * @return {string} Block ID popped from the stack.
                */
            popStack(): string;
            /**
                * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied
                */
            stopThisScript(): void;
            /**
                * Get top stack item.
                * @return {?string} Block ID on top of stack.
                */
            peekStack(): string | null;
            /**
                * Get top stack frame.
                * @return {?object} Last stack frame stored on this thread.
                */
            peekStackFrame(): object | null;
            /**
                * Get stack frame above the current top.
                * @return {?object} Second to last stack frame stored on this thread.
                */
            peekParentStackFrame(): object | null;
            /**
                * Push a reported value to the parent of the current stack frame.
                * @param {*} value Reported value to push.
                */
            pushReportedValue(value: any): void;
            /**
                * Initialize procedure parameters on this stack frame.
                */
            initParams(): void;
            /**
                * Add a parameter to the stack frame.
                * Use when calling a procedure with parameter values.
                * @param {!string} paramName Name of parameter.
                * @param {*} value Value to set for parameter.
                */
            pushParam(paramName: string, value: any): void;
            getHatParam(paramName: any): any;
            /**
                * Get a parameter at the lowest possible level of the stack.
                * @param {!string} paramName Name of parameter.
                * @return {*} value Value for parameter.
                */
            getParam(paramName: string): any;
            getAllparams(): any;
            /**
                * Whether the current execution of a thread is at the top of the stack.
                * @return {boolean} True if execution is at top of the stack.
                */
            atStackTop(): boolean;
            /**
                * Switch the thread to the next block at the current level of the stack.
                * For example, this is used in a standard sequence of blocks,
                * where execution proceeds from one block to the next.
                */
            goToNextBlock(): void;
            /**
                * Attempt to determine whether a procedure call is recursive,
                * by examining the stack.
                * @param {!string} procedureCode Procedure code of procedure being called.
                * @return {boolean} True if the call appears recursive.
                */
            isRecursiveCall(procedureCode: string): boolean;
            /**
                * Attempt to compile this thread.
                */
            tryCompile(): void;
    }
    namespace Thread {
            export { _StackFrame };
    }
    /**
        * A frame used for each level of the stack. A general purpose
        * place to store a bunch of execution context and parameters
        * @param {boolean} warpMode Whether this level of the stack is warping
        * @constructor
        * @private
        */
    class _StackFrame {
            /**
                * Create or recycle a stack frame object.
                * @param {boolean} warpMode Enable warpMode on this frame.
                * @returns {_StackFrame} The clean stack frame with correct warpMode setting.
                */
            static create(warpMode: boolean): _StackFrame;
            /**
                * Put a stack frame object into the recycle bin for reuse.
                * @param {_StackFrame} stackFrame The frame to reset and recycle.
                */
            static release(stackFrame: _StackFrame): void;
            constructor(warpMode: any);
            /**
                * Whether this level of the stack is a loop.
                * @type {boolean}
                */
            isLoop: boolean;
            /**
                * Whether this level is in warp mode.  Is set by some legacy blocks and
                * "turbo mode"
                * @type {boolean}
                */
            warpMode: boolean;
            /**
                * Reported value from just executed block.
                * @type {Any}
                */
            justReported: any;
            /**
                * The active block that is waiting on a promise.
                * @type {string}
                */
            reporting: string;
            /**
                * Persists reported inputs during async block.
                * @type {Object}
                */
            reported: Object;
            /**
                * Name of waiting reporter.
                * @type {string}
                */
            waitingReporter: string;
            /**
                * Procedure parameters.
                * @type {Object}
                */
            params: Object;
            /**
                * A context passed to block implementations.
                * @type {Object}
                */
            executionContext: Object;
            /**
                * Internal block object being executed. This is *not* the same as the object found
                * in target.blocks.
                * @type {object}
                */
            op: object;
            /**
                * Reset all properties of the frame to pristine null and false states.
                * Used to recycle.
                * @return {_StackFrame} this
                */
            reset(): _StackFrame;
            /**
                * Reuse an active stack frame in the stack.
                * @param {?boolean} warpMode defaults to current warpMode
                * @returns {_StackFrame} this
                */
            reuse(warpMode?: boolean | null): _StackFrame;
    }
}

declare module 'scratch-vm-dts/engine/tw-frame-loop' {
    export = FrameLoop;
    class FrameLoop {
        constructor(runtime: any);
        runtime: any;
        running: boolean;
        stepCallback(): void;
        interpolationCallback(): void;
        _stepInterval: NodeJS.Timeout | null;
        _interpolationAnimation: {
            cancel: () => void;
        } | null;
        _stepAnimation: {
            cancel: () => void;
        } | null;
        setFramerate(fps: any): void;
        framerate: any;
        setInterpolation(interpolation: any): void;
        interpolation: any;
        _restart(): void;
        start(): void;
        stop(): void;
    }
}

declare module 'scratch-vm-dts/engine/profiler' {
    export = Profiler;
    class Profiler {
            /**
                * Lookup or create an id for a frame name.
                * @static
                * @param {string} name The name to return an id for.
                * @return {number} The id for the passed name.
                */
            static idByName(name: string): number;
            /**
                * Reverse lookup the name from a given frame id.
                * @static
                * @param {number} id The id to search for.
                * @return {string} The name for the given id.
                */
            static nameById(id: number): string;
            /**
                * Profiler is only available on platforms with the Performance API.
                * @return {boolean} Can the Profiler run in this browser?
                */
            static available(): boolean;
            /**
                * @param {FrameCallback} onFrame a handle called for each recorded frame.
                * The passed frame value may not be stored as it'll be updated with later
                * frame information. Any information that is further stored by the handler
                * should make copies or reduce the information.
                */
            constructor(onFrame?: FrameCallback);
            /**
                * A series of START and STOP values followed by arguments. After
                * recording is complete the full set of records is reported back by
                * stepping through the series to connect the relative START and STOP
                * information.
                * @type {Array.<*>}
                */
            records: Array<any>;
            /**
                * An array of frames incremented on demand instead as part of start
                * and stop.
                * @type {Array.<ProfilerFrame>}
                */
            increments: Array<ProfilerFrame>;
            /**
                * An array of profiler frames separated by counter argument. Generally
                * for Scratch these frames are separated by block function opcode.
                * This tracks each time an opcode is called.
                * @type {Array.<ProfilerFrame>}
                */
            counters: Array<ProfilerFrame>;
            /**
                * A frame with no id or argument.
                * @type {ProfilerFrame}
                */
            nullFrame: ProfilerFrame;
            /**
                * A cache of ProfilerFrames to reuse when reporting the recorded
                * frames in records.
                * @type {Array.<ProfilerFrame>}
                */
            _stack: Array<ProfilerFrame>;
            /**
                * A callback handle called with each decoded frame when reporting back
                * all the recorded times.
                * @type {FrameCallback}
                */
            onFrame: FrameCallback;
            /**
                * A reference to the START record id constant.
                * @const {number}
                */
            START: number;
            /**
                * A reference to the STOP record id constant.
                * @const {number}
                */
            STOP: number;
            /**
                * Start recording a frame of time for an id and optional argument.
                * @param {number} id The id returned by idByName for a name symbol like
                * Runtime._step.
                * @param {?*} arg An arbitrary argument value to store with the frame.
                */
            start(id: number, arg: any | null): void;
            /**
                * Stop the current frame.
                */
            stop(): void;
            /**
                * Increment the number of times this symbol is called.
                * @param {number} id The id returned by idByName for a name symbol.
                */
            increment(id: number): void;
            /**
                * Find or create a ProfilerFrame-like object whose counter can be
                * incremented outside of the Profiler.
                * @param {number} id The id returned by idByName for a name symbol.
                * @param {*} arg The argument for a frame that identifies it in addition
                *   to the id.
                * @return {{count: number}} A ProfilerFrame-like whose count should be
                *   incremented for each call.
                */
            frame(id: number, arg: any): {
                    count: number;
            };
            /**
                * Decode records and report all frames to `this.onFrame`.
                */
            reportFrames(): void;
            /**
                * Lookup or create an id for a frame name.
                * @param {string} name The name to return an id for.
                * @return {number} The id for the passed name.
                */
            idByName(name: string): number;
            /**
                * Reverse lookup the name from a given frame id.
                * @param {number} id The id to search for.
                * @return {string} The name for the given id.
                */
            nameById(id: number): string;
    }
    namespace Profiler {
            export { START, STOP, FrameCallback };
    }
    /**
        * A set of information about a frame of execution that was recorded.
        */
    class ProfilerFrame {
            /**
                * @param {number} depth Depth of the frame in the recorded stack.
                */
            constructor(depth: number);
            /**
                * The numeric id of a record symbol like Runtime._step or
                * blockFunction.
                * @type {number}
                */
            id: number;
            /**
                * The amount of time spent inside the recorded frame and any deeper
                * frames.
                * @type {number}
                */
            totalTime: number;
            /**
                * The amount of time spent only inside this record frame. Not
                * including time in any deeper frames.
                * @type {number}
                */
            selfTime: number;
            /**
                * An arbitrary argument for the recorded frame. For example a block
                * function might record its opcode as an argument.
                * @type {*}
                */
            arg: any;
            /**
                * The depth of the recorded frame. This can help compare recursive
                * funtions that are recorded. Each level of recursion with have a
                * different depth value.
                * @type {number}
                */
            depth: number;
            /**
                * A summarized count of the number of calls to this frame.
                * @type {number}
                */
            count: number;
    }
    /**
        * The START event identifier in Profiler records.
        * @const {number}
        */
    const START: 0;
    /**
        * The STOP event identifier in Profiler records.
        * @const {number}
        */
    const STOP: 1;
    /**
        * Callback handle called by Profiler for each frame it decodes from its
        * records.
        */
    type FrameCallback = (frame: ProfilerFrame) => any;
}

declare module 'scratch-vm-dts/util/log-system' {
    export = LogSystem;
    import { EventEmitter } from 'node:events';
    class LogSystem extends EventEmitter{
    }
}

declare module 'scratch-vm-dts/util/gandi' {
    export = Gandi;
    class Gandi {
            /**
                * Constructor for the Gandi class.
                * @constructor
                * @param {Object} runtime - The runtime object.
                */
            constructor(runtime: Object);
            /**
                * The runtime object.
                * @member {Object}
                */
            runtime: Object;
            /**
                * Array to store properties.
                * @member {Array}
                */
            properties: string[];
            /**
                * default supported asset types
                */
            _supportedAssetTypes: any[];
            merge(data: any): {
                    assets: any;
                    wildExtensions: any;
            } | null;
            configs: any;
            wildExtensions: any;
            dynamicMenuItems: any;
            spine: any;
            assets: any;
            setup(): void;
            set supportedAssetTypes(types: any[]);
            get supportedAssetTypes(): any[];
            clear(): void;
            /**
                * Checks if all properties are empty.
                * @method
                * @returns {boolean} - True if all properties are empty, false otherwise.
                */
            isEmpty(): boolean;
            /**
                * Checks if a specific property is empty.
                * @method
                * @param {string} propertyName - The name of the property to check.
                * @returns {boolean} - True if the property is empty, false otherwise.
                */
            istPropertyEmpty(propertyName: string): boolean;
            /**
                * Serializes Gandi assets.
                * @method
                * @param {Set} extensions - Set of extensions.
                * @returns {Array} - Serialized Gandi assets.
                */
            serializeGandiAssets(extensions: Set<any>): any[];
            /**
                * Checks if an object is empty.
                * @method
                * @param {Object} object - The object to check.
                * @returns {boolean} - True if the object is empty, false otherwise.
                */
            isEmptyObject(object: Object): boolean;
            /**
                * Serializes Gandi data.
                * @method
                * @param {Object} object - The object to serialize.
                * @param {Set} extensions - Set of extensions.
                */
            serialize(extensions: Set<any>): {
                    wildExtensions: {};
            } | {
                    spine: any;
            } | {
                    dynamicMenuItems: any;
            } | {
                    configs: any;
            } | {
                    assets: any[];
            } | undefined;
            /**
                * Adds a Spine asset.
                * @method
                * @param {string} key - The key for the Spine asset.
                * @param {Object} data - The data for the Spine asset.
                */
            addSpineAsset(key: string, data: Object): void;
            /**
                * Deletes a Spine asset.
                * @method
                * @param {string} key - The key of the Spine asset to delete.
                */
            deleteSpineAsset(key: string): void;
            /**
                * Gets a Spine asset by name.
                * @method
                * @param {string} name - The name of the Spine asset.
                * @returns {Object} - The Spine asset data.
                */
            getSpineAsset(name: string): Object;
            /**
                * Sets the value of a configuration item.
                * @param {string} key - The key of the configuration item.
                * @param {*} value - The value to set.
                * @returns {void}
                */
            setConfig(key: string, value: any): void;
            /**
                * Gets the value of a specified configuration item.
                * @param {string} key - The key of the configuration item to retrieve the value.
                * @returns {*} The value of the specified configuration item, or undefined if it doesn't exist.
                */
            getConfig(key: string): any;
            /**
                * Adds a dynamic menu item.
                * @method
                * @param {string} menuName - The name of the dynamic menu.
                * @param {Object} menuItem - The dynamic menu item to add.
                */
            addDynamicMenuItem(menuName: string, menuItem: Object): void;
            /**
                * Gets dynamic menu items by name.
                * @method
                * @param {string} menuName - The name of the dynamic menu.
                * @returns {Array} - Array of dynamic menu items.
                */
            getDynamicMenuItems(menuName: string): any[];
            /**
                * Deletes dynamic menu items.
                * @method
                * @param {string} menuName - The name of the dynamic menu.
                * @param {string} id - The id of the dynamic menu item to delete.
                * @throws Will throw an error if the menu name is not provided.
                */
            deleteDynamicMenuItems(menuName: string, id: string): void;
            /**
                * Adds a wild extension.
                * @method
                * @param {Object} data - The data for the wild extension.
                */
            addWildExtension({ id, url }: Object): void;
            /**
                     * Deletes a wild extension.
                     * @method
                     * @param {string} id - The id of the wild extension to delete.
                     */
            deleteWildExtension(id: string): void;
            getExtensionAssets(): any;
            isExtensionURLInGandiAssets(url: any): any;
    }
}

declare module 'scratch-vm-dts/engine/tw-font-manager' {
    export = FontManager;
    import Runtime from "scratch-vm-dts/engine/runtime";
    import JSZip from "jszip";
    class Asset{}
    /**
        * @typedef InternalFont
        * @property {boolean} system True if the font is built in to the system
        * @property {string} family The font's name
        * @property {string} fallback Fallback font family list
        * @property {Asset} [asset] scratch-storage asset if system: false
        */
    class FontManager extends EventEmitter<[never]> {
            /**
                * @param {Runtime} runtime
                */
            constructor(runtime: Runtime);
            runtime: Runtime;
            /** @type {Array<InternalFont>} */
            fonts: Array<InternalFont>;
            /**
                * @param {string} family An unknown font family
                * @returns {boolean} true if the family is valid
                */
            isValidFamily(family: string): boolean;
            /**
                * @param {string} family
                * @returns {boolean}
                */
            hasFont(family: string): boolean;
            /**
                * @param {string} family
                * @returns {boolean}
                */
            getSafeName(family: string): boolean;
            changed(): void;
            /**
                * @param {string} family
                * @param {string} fallback
                */
            addSystemFont(family: string, fallback: string): void;
            /**
                * @param {string} family
                * @param {string} fallback
                * @param {Asset} asset scratch-storage asset
                */
            addCustomFont(family: string, fallback: string, asset: Asset): void;
            /**
                * @returns {Array<{system: boolean; name: string; family: string; data: Uint8Array | null; format: string | null}>}
                */
            getFonts(): Array<{
                    system: boolean;
                    name: string;
                    family: string;
                    data: Uint8Array | null;
                    format: string | null;
            }>;
            /**
                * @param {number} index Corresponds to index from getFonts()
                */
            deleteFont(index: number): void;
            clear(): void;
            updateRenderer(): void;
            /**
                * Get data to save in project.json and sb3 files.
                */
            serializeJSON(): {
                    system: boolean;
                    family: string;
                    fallback: string;
            }[] | null;
            /**
                * @returns {Asset[]} list of scratch-storage assets
                */
            serializeAssets(): Asset[];
            /**
                * @param {unknown} json
                * @param {JSZip} [zip]
                * @param {boolean} [keepExisting]
                * @returns {Promise<void>}
                */
            deserialize(json: unknown, zip?: JSZip, keepExisting?: boolean): Promise<void>;
    }
    namespace FontManager {
            export { InternalFont };
    }
    import EventEmitter = require("events");
    type InternalFont = {
            /**
                * True if the font is built in to the system
                */
            system: boolean;
            /**
                * The font's name
                */
            family: string;
            /**
                * Fallback font family list
                */
            fallback: string;
            /**
                * scratch-storage asset if system: false
                */
            asset?: Asset;
    };
}

declare module 'scratch-vm-dts/extension-support/argument-type' {
    export = ArgumentType;
    /**
      * Block argument types
      */
    type ArgumentType = string;
    namespace ArgumentType {
        let ANGLE: string;
        let BOOLEAN: string;
        let COLOR: string;
        let NUMBER: string;
        let STRING: string;
        let MATRIX: string;
        let NOTE: string;
        let IMAGE: string;
        let XIGUA_MATRIX: string;
        let XIGUA_WHITE_BOARD_NOTE: string;
        let CCW_HAT_PARAMETER: string;
        let COSTUME: string;
        let SOUND: string;
    }
}

declare module 'scratch-vm-dts/extension-support/extension-metadata' {
    export = ExtensionMetadata
    import BlockType from 'scratch-vm-dts/extension-support/block-type';
    import ArgumentType from 'scratch-vm-dts/extension-support/argument-type';
    class int extends Number{}
    /**
        * All the metadata needed to register an extension.
        */
    type ExtensionMetadata = {
            /**
                * - a unique alphanumeric identifier for this extension. No special characters allowed.
                */
            id: string;
            /**
                * - the human-readable name of this extension.
                */
            name?: string | undefined;
            /**
                * - URI for an image to be placed on each block in this extension. Data URI ok.
                */
            blockIconURI?: string | undefined;
            /**
                * - URI for an image to be placed on this extension's category menu item. Data URI ok.
                */
            menuIconURI?: string | undefined;
            /**
                * - link to documentation content for this extension.
                */
            docsURI?: string | undefined;
            /**
                * - the blocks provided by this extension, plus separators.
                */
            blocks: Array<ExtensionBlockMetadata | string>;
            /**
                * - map of menu name to metadata for each of this extension's menus.
                */
            menus?: ExtensionMenuMetadata;
    };
    /**
        * All the metadata needed to register an extension block.
        */
    type ExtensionBlockMetadata = {
            /**
                * - a unique alphanumeric identifier for this block. No special characters allowed.
                */
            opcode: string;
            /**
                * - the name of the function implementing this block. Can be shared by other blocks/opcodes.
                */
            func?: string | undefined;
            /**
                * - the type of block (command, reporter, etc.) being described.
                */
            blockType: BlockType;
            /**
                * - the text on the block, with [PLACEHOLDERS] for arguments.
                */
            text: string;
            /**
                * - the human-readable tooltip for this block.
                */
            tooltip?: string | undefined;
            /**
                * - true if this block should not appear in the block palette.
                */
            hideFromPalette?: boolean | undefined;
            /**
                * - true if the block ends a stack - no blocks can be connected after it.
                */
            isTerminal?: boolean | undefined;
            /**
                * - true if this block is a reporter but should not allow a monitor.
                */
            disableMonitor?: boolean | undefined;
            /**
                * - if this block is a reporter, this is the scope/context for its value.
                */
            reporterScope?: object;
            /**
                * - sets whether a hat block is edge-activated.
                */
            isEdgeActivated?: boolean | undefined;
            /**
                * - sets whether a hat/event block should restart existing threads.
                */
            shouldRestartExistingThreads?: boolean | undefined;
            /**
                * - for flow control blocks, the number of branches/substacks for this block.
                */
            branchCount?: int;
            /**
                * - map of argument placeholder to metadata about each arg.
                */
            arguments?: ExtensionArgumentMetadata;
    };
    /**
        * All the metadata needed to register an argument for an extension block.
        */
    type ExtensionArgumentMetadata = {
            /**
                * - the type of the argument (number, string, etc.)
                */
            type: ArgumentType;
            /**
                * - the default value of this argument.
                */
            defaultValue?: any;
            /**
                * - the name of the menu to use for this argument, if any.
                */
            menu?: string | undefined;
    };
    /**
        * All the metadata needed to register an extension drop-down menu.
        */
    type ExtensionMenuMetadata = ExtensionDynamicMenu | ExtensionMenuItems;
    /**
        * The string name of a function which returns menu items.
        */
    type ExtensionDynamicMenu = string;
    /**
        * Items in an extension menu.
        */
    type ExtensionMenuItems = Array<ExtensionMenuItemSimple | ExtensionMenuItemComplex>;
    /**
        * A menu item for which the label and value are identical strings.
        */
    type ExtensionMenuItemSimple = string;
    /**
        * A menu item for which the label and value can differ.
        */
    type ExtensionMenuItemComplex = {
            /**
                * - the value of the block argument when this menu item is selected.
                */
            value: any;
            /**
                * - the human-readable label of this menu item in the menu.
                */
            text: string;
    };
}

declare module 'scratch-vm-dts/blocks/scratch3_core_example' {
    export = Scratch3CoreExample;
    import Runtime from '../engine/runtime'
    /**
        * An example core block implemented using the extension spec.
        * This is not loaded as part of the core blocks in the VM but it is provided
        * and used as part of tests.
        */
    class Scratch3CoreExample {
            constructor(runtime: any);
            /**
                * The runtime instantiating this block package.
                * @type {Runtime}
                */
            runtime: Runtime;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            /**
                * Example opcode just returns the name of the stage target.
                * @returns {string} The name of the first target in the project.
                */
            exampleOpcode(): string;
            exampleWithInlineImage(): void;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_wedo2' {
    export = Scratch3WeDo2Blocks;
    /**
        * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.
        */
    class Scratch3WeDo2Blocks {
            /**
                * @return {string} - the ID of this extension.
                */
            static get EXTENSION_ID(): string;
            /**
                * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
                */
            static get TILT_THRESHOLD(): number;
            /**
                * Construct a set of WeDo 2.0 blocks.
                * @param {Runtime} runtime - the Scratch 3.0 runtime.
                */
            constructor(runtime: Runtime);
            /**
                * The Scratch 3.0 runtime.
                * @type {Runtime}
                */
            runtime: Runtime;
            _peripheral: WeDo2;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            /**
                * Turn specified motor(s) on for a specified duration.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to activate.
                * @property {int} DURATION - the amount of time to run the motors.
                * @return {Promise} - a promise which will resolve at the end of the duration.
                */
            motorOnFor(args: object): Promise<any>;
            /**
                * Turn specified motor(s) on indefinitely.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to activate.
                * @return {Promise} - a Promise that resolves after some delay.
                */
            motorOn(args: object): Promise<any>;
            /**
                * Turn specified motor(s) off.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
                * @return {Promise} - a Promise that resolves after some delay.
                */
            motorOff(args: object): Promise<any>;
            /**
                * Turn specified motor(s) off.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
                * @property {int} POWER - the new power level for the motor(s).
                * @return {Promise} - a Promise that resolves after some delay.
                */
            startMotorPower(args: object): Promise<any>;
            /**
                * Set the direction of rotation for specified motor(s).
                * If the direction is 'reverse' the motor(s) will be reversed individually.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
                * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
                * @return {Promise} - a Promise that resolves after some delay.
                */
            setMotorDirection(args: object): Promise<any>;
            /**
                * Set the LED's hue.
                * @param {object} args - the block's arguments.
                * @property {number} HUE - the hue to set, in the range [0,100].
                * @return {Promise} - a Promise that resolves after some delay.
                */
            setLightHue(args: object): Promise<any>;
            /**
                * Make the WeDo 2.0 peripheral play a MIDI note for the specified duration.
                * @param {object} args - the block's arguments.
                * @property {number} NOTE - the MIDI note to play.
                * @property {number} DURATION - the duration of the note, in seconds.
                * @return {Promise} - a promise which will resolve at the end of the duration.
                */
            playNoteFor(args: object): Promise<any>;
            /**
                * Compare the distance sensor's value to a reference.
                * @param {object} args - the block's arguments.
                * @property {string} OP - the comparison operation: '<' or '>'.
                * @property {number} REFERENCE - the value to compare against.
                * @return {boolean} - the result of the comparison, or false on error.
                */
            whenDistance(args: object): boolean;
            /**
                * Test whether the tilt sensor is currently tilted.
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
                * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
                */
            whenTilted(args: object): boolean;
            /**
                * @return {number} - the distance sensor's value, scaled to the [0,100] range.
                */
            getDistance(): number;
            /**
                * Test whether the tilt sensor is currently tilted.
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
                * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
                */
            isTilted(args: object): boolean;
            /**
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
                * @return {number} - the tilt sensor's angle in the specified direction.
                * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
                */
            getTiltAngle(args: object): number;
    }
    /**
        * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.
        */
    class WeDo2 {
            constructor(runtime: any, extensionId: any);
            /**
                * The id of the extension this peripheral belongs to.
                */
            _extensionId: any;
            /**
                * Reset all the state and timeout/interval ids.
                */
            reset(): void;
            /**
                * Check the battery level on the WeDo 2.0. If the WeDo 2.0 has disconnected
                * for some reason, the BLE socket will get an error back and automatically
                * close the socket.
                */
            _checkBatteryLevel(): void;
            /**
                * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
                */
            get tiltX(): number;
            /**
                * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
                */
            get tiltY(): number;
            /**
                * @return {number} - the latest value received from the distance sensor.
                */
            get distance(): number;
            /**
                * Access a particular motor on this peripheral.
                * @param {int} index - the zero-based index of the desired motor.
                * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.
                */
            motor(index: int): WeDo2Motor;
            /**
                * Stop all the motors that are currently running.
                */
            stopAllMotors(): void;
            /**
                * Set the WeDo 2.0 peripheral's LED to a specific color.
                * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
                * @return {Promise} - a promise of the completion of the set led send operation.
                */
            setLED(inputRGB: int): Promise<any>;
            /**
                * Sets the input mode of the LED to RGB.
                * @return {Promise} - a promise returned by the send operation.
                */
            setLEDMode(): Promise<any>;
            /**
                * Switch off the LED on the WeDo 2.0.
                * @return {Promise} - a promise of the completion of the stop led send operation.
                */
            stopLED(): Promise<any>;
            /**
                * Play a tone from the WeDo 2.0 peripheral for a specific amount of time.
                * @param {int} tone - the pitch of the tone, in Hz.
                * @param {int} milliseconds - the duration of the note, in milliseconds.
                * @return {Promise} - a promise of the completion of the play tone send operation.
                */
            playTone(tone: int, milliseconds: int): Promise<any>;
            /**
                * Stop the tone playing from the WeDo 2.0 peripheral, if any.
                * @return {Promise} - a promise that the command sent.
                */
            stopTone(): Promise<any>;
            /**
                * Stop the tone playing and motors on the WeDo 2.0 peripheral.
                */
            stopAll(): void;
            /**
                * Called by the runtime when user wants to scan for a WeDo 2.0 peripheral.
                */
            scan(): void;
            /**
                * Called by the runtime when user wants to connect to a certain WeDo 2.0 peripheral.
                * @param {number} id - the id of the peripheral to connect to.
                */
            connect(id: number): void;
            /**
                * Disconnects from the current BLE socket.
                */
            disconnect(): void;
            /**
                * Called by the runtime to detect whether the WeDo 2.0 peripheral is connected.
                * @return {boolean} - the connected state.
                */
            isConnected(): boolean;
            /**
                * Write a message to the WeDo 2.0 peripheral BLE socket.
                * @param {number} uuid - the UUID of the characteristic to write to
                * @param {Array} message - the message to write.
                * @param {boolean} [useLimiter=true] - if true, use the rate limiter
                * @return {Promise} - a promise result of the write operation
                */
            send(uuid: number, message: any[], useLimiter?: boolean): Promise<any>;
            /**
                * Generate a WeDo 2.0 'Output Command' in the byte array format
                * (CONNECT ID, COMMAND ID, NUMBER OF BYTES, VALUES ...).
                *
                * This sends a command to the WeDo 2.0 to actuate the specified outputs.
                *
                * @param  {number} connectID - the port (Connect ID) to send a command to.
                * @param  {number} commandID - the id of the byte command.
                * @param  {array}  values    - the list of values to write to the command.
                * @return {array}            - a generated output command.
                */
            generateOutputCommand(connectID: number, commandID: number, values?: array): array;
            /**
                * Generate a WeDo 2.0 'Input Command' in the byte array format
                * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
                * UNIT, NOTIFICATIONS ENABLED).
                *
                * This sends a command to the WeDo 2.0 that sets that input format
                * of the specified inputs and sets value change notifications.
                *
                * @param  {number}  connectID           - the port (Connect ID) to send a command to.
                * @param  {number}  type                - the type of input sensor.
                * @param  {number}  mode                - the mode of the input sensor.
                * @param  {number}  delta               - the delta change needed to trigger notification.
                * @param  {array}   units               - the unit of the input sensor value.
                * @param  {boolean} enableNotifications - whether to enable notifications.
                * @return {array}                       - a generated input command.
                */
            generateInputCommand(connectID: number, type: number, mode: number, delta: number, units: array, enableNotifications: boolean): array;
    }
    /**
        * Manage power, direction, and timers for one WeDo 2.0 motor.
        */
    class WeDo2Motor {
            /**
                * Construct a WeDo 2.0 Motor instance.
                * @param {WeDo2} parent - the WeDo 2.0 peripheral which owns this motor.
                * @param {int} index - the zero-based index of this motor on its parent peripheral.
                */
            constructor(parent: WeDo2, index: int);
            /**
                * Start active braking on this motor. After a short time, the motor will turn off.
                */
            startBraking(): void;
            /**
                * Turn this motor off.
                * @param {boolean} [useLimiter=true] - if true, use the rate limiter
                */
            turnOff(useLimiter?: boolean): void;
            /**
                * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
                */
            set direction(value: int);
            /**
                * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
                */
            get direction(): int;
            /**
                * @param {int} value - this motor's new power level, in the range [0,100].
                */
            set power(value: int);
            /**
                * @return {int} - this motor's current power level, in the range [0,100].
                */
            get power(): int;
            /**
                * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.
                */
            get isOn(): boolean;
            /**
                * @return {boolean} - time, in milliseconds, of when the pending timeout began.
                */
            get pendingTimeoutStartTime(): boolean;
            /**
                * @return {boolean} - delay, in milliseconds, of the pending timeout.
                */
            get pendingTimeoutDelay(): boolean;
            /**
                * Turn this motor on indefinitely.
                */
            turnOn(): void;
            /**
                * Turn this motor on for a specific duration.
                * @param {number} milliseconds - run the motor for this long.
                */
            turnOnFor(milliseconds: number): void;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_microbit' {
    export = Scratch3MicroBitBlocks;
    /**
        * Scratch 3.0 blocks to interact with a MicroBit peripheral.
        */
    class Scratch3MicroBitBlocks {
            /**
                * @return {string} - the name of this extension.
                */
            static get EXTENSION_NAME(): string;
            /**
                * @return {string} - the ID of this extension.
                */
            static get EXTENSION_ID(): string;
            /**
                * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
                */
            static get TILT_THRESHOLD(): number;
            /**
                * Construct a set of MicroBit blocks.
                * @param {Runtime} runtime - the Scratch 3.0 runtime.
                */
            constructor(runtime: Runtime);
            /**
                * @return {array} - text and values for each buttons menu element
                */
            get BUTTONS_MENU(): array;
            /**
                * @return {array} - text and values for each gestures menu element
                */
            get GESTURES_MENU(): array;
            /**
                * @return {array} - text and values for each pin state menu element
                */
            get PIN_STATE_MENU(): array;
            /**
                * @return {array} - text and values for each tilt direction menu element
                */
            get TILT_DIRECTION_MENU(): array;
            /**
                * @return {array} - text and values for each tilt direction (plus "any") menu element
                */
            get TILT_DIRECTION_ANY_MENU(): array;
            /**
                * The Scratch 3.0 runtime.
                * @type {Runtime}
                */
            runtime: Runtime;
            _peripheral: MicroBit;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            /**
                * Test whether the A or B button is pressed
                * @param {object} args - the block's arguments.
                * @return {boolean} - true if the button is pressed.
                */
            whenButtonPressed(args: object): boolean;
            /**
                * Test whether the A or B button is pressed
                * @param {object} args - the block's arguments.
                * @return {boolean} - true if the button is pressed.
                */
            isButtonPressed(args: object): boolean;
            /**
                * Test whether the micro:bit is moving
                * @param {object} args - the block's arguments.
                * @return {boolean} - true if the micro:bit is moving.
                */
            whenGesture(args: object): boolean;
            /**
                * Display a predefined symbol on the 5x5 LED matrix.
                * @param {object} args - the block's arguments.
                * @return {Promise} - a Promise that resolves after a tick.
                */
            displaySymbol(args: object): Promise<any>;
            /**
                * Display text on the 5x5 LED matrix.
                * @param {object} args - the block's arguments.
                * @return {Promise} - a Promise that resolves after the text is done printing.
                * Note the limit is 19 characters
                * The print time is calculated by multiplying the number of horizontal pixels
                * by the default scroll delay of 120ms.
                * The number of horizontal pixels = 6px for each character in the string,
                * 1px before the string, and 5px after the string.
                */
            displayText(args: object): Promise<any>;
            /**
                * Turn all 5x5 matrix LEDs off.
                * @return {Promise} - a Promise that resolves after a tick.
                */
            displayClear(): Promise<any>;
            /**
                * Test whether the tilt sensor is currently tilted.
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
                * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
                */
            whenTilted(args: object): boolean;
            /**
                * Test whether the tilt sensor is currently tilted.
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
                * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
                */
            isTilted(args: object): boolean;
            /**
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.
                * @return {number} - the tilt sensor's angle in the specified direction.
                * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
                */
            getTiltAngle(args: object): number;
    }
    /**
        * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
        */
    class MicroBit {
            /**
                * Construct a MicroBit communication object.
                * @param {Runtime} runtime - the Scratch 3.0 runtime
                * @param {string} extensionId - the id of the extension
                */
            constructor(runtime: Runtime, extensionId: string);
            /**
                * The id of the extension this peripheral belongs to.
                */
            _extensionId: string;
            /**
                * ID for a timeout which is used to clear the busy flag if it has been
                * true for a long time.
                */
            _busyTimeoutID: number | null;
            /**
                * Reset all the state and timeout/interval ids.
                */
            reset(): void;
            /**
                * @param {string} text - the text to display.
                * @return {Promise} - a Promise that resolves when writing to peripheral.
                */
            displayText(text: string): Promise<any>;
            /**
                * @param {Uint8Array} matrix - the matrix to display.
                * @return {Promise} - a Promise that resolves when writing to peripheral.
                */
            displayMatrix(matrix: Uint8Array): Promise<any>;
            /**
                * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
                */
            get tiltX(): number;
            /**
                * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
                */
            get tiltY(): number;
            /**
                * @return {boolean} - the latest value received for the A button.
                */
            get buttonA(): boolean;
            /**
                * @return {boolean} - the latest value received for the B button.
                */
            get buttonB(): boolean;
            /**
                * @return {number} - the latest value received for the motion gesture states.
                */
            get gestureState(): number;
            /**
                * @return {Uint8Array} - the current state of the 5x5 LED matrix.
                */
            get ledMatrixState(): Uint8Array;
            /**
                * Called by the runtime when user wants to scan for a peripheral.
                */
            scan(): void;
            /**
                * Called by the runtime when user wants to connect to a certain peripheral.
                * @param {number} id - the id of the peripheral to connect to.
                */
            connect(id: number): void;
            /**
                * Disconnect from the micro:bit.
                */
            disconnect(): void;
            /**
                * Return true if connected to the micro:bit.
                * @return {boolean} - whether the micro:bit is connected.
                */
            isConnected(): boolean;
            /**
                * Send a message to the peripheral BLE socket.
                * @param {number} command - the BLE command hex.
                * @param {Uint8Array} message - the message to write
                */
            send(command: number, message: Uint8Array): void;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_text2speech' {
    export = Scratch3Text2SpeechBlocks;
    /**
        * Class for the text2speech blocks.
        * @constructor
        */
    class Scratch3Text2SpeechBlocks {
            /**
                * The key to load & store a target's text2speech state.
                * @return {string} The key.
                */
            static get STATE_KEY(): string;
            /**
                * The default state, to be used when a target has no existing state.
                * @type {Text2SpeechState}
                */
            static get DEFAULT_TEXT2SPEECH_STATE(): Text2SpeechState;
            constructor(runtime: any);
            /**
                * The runtime instantiating this block package.
                * @type {Runtime}
                */
            runtime: Runtime;
            /**
                * Map of soundPlayers by sound id.
                * @type {Map<string, SoundPlayer>}
                */
            _soundPlayers: Map<string, SoundPlayer>;
            /**
                * Stop all currently playing speech sounds.
                */
            _stopAllSpeech(): void;
            /**
                * A list of all Scratch locales that are supported by the extension.
                * @type {Array}
                */
            _supportedLocales: any[];
            thirdPartApiKey: string;
            host: any;
            isCCWService: boolean | undefined;
            /**
                * An object with info for each voice.
                */
            get VOICE_INFO(): {
                    ALTO: {
                            name: string;
                            gender: string;
                            playbackRate: number;
                    };
                    TENOR: {
                            name: string;
                            gender: string;
                            playbackRate: number;
                    };
                    SQUEAK: {
                            name: string;
                            gender: string;
                            playbackRate: number;
                    };
                    GIANT: {
                            name: string;
                            gender: string;
                            playbackRate: number;
                    };
                    KITTEN: {
                            name: string;
                            gender: string;
                            playbackRate: number;
                    };
            };
            /**
                * An object with information for each language.
                *
                * A note on the different sets of locales referred to in this extension:
                *
                * SCRATCH LOCALE
                *      Set by the editor, and used to store the language state in the project.
                *      Listed in l10n: https://github.com/scratchfoundation/scratch-l10n/blob/master/src/supported-locales.js
                * SUPPORTED LOCALE
                *      A Scratch locale that has a corresponding extension locale.
                * EXTENSION LOCALE
                *      A locale corresponding to one of the available spoken languages
                *      in the extension. There can be multiple supported locales for a single
                *      extension locale. For example, for both written versions of chinese,
                *      zh-cn and zh-tw, we use a single spoken language (Mandarin). So there
                *      are two supported locales, with a single extension locale.
                * SPEECH SYNTH LOCALE
                *      A different locale code system, used by our speech synthesis service.
                *      Each extension locale has a speech synth locale.
                */
            get LANGUAGE_INFO(): {
                    ar: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                            singleGender: boolean;
                    };
                    "zh-cn": {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                            singleGender: boolean;
                    };
                    en: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
                    fr: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
                    de: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
                    ja: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
                    ko: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                            singleGender: boolean;
                    };
                    pt: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
                    ru: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
                    es: {
                            name: string;
                            locales: string[];
                            speechSynthLocale: string;
                    };
            };
            /**
                * A default language to use for speech synthesis.
                * @type {string}
                */
            get DEFAULT_LANGUAGE(): string;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            /**
                * Get the language code currently set in the editor, or fall back to the
                * browser locale.
                * @return {string} a Scratch locale code.
                */
            getEditorLanguage(): string;
            /**
                * Get the language code currently set for the extension.
                * @returns {string} a Scratch locale code.
                */
            getCurrentLanguage(): string;
            /**
                * Set the language code for the extension.
                * It is stored in the stage so it can be saved and loaded with the project.
                * @param {string} locale a locale code.
                */
            setCurrentLanguage(locale: string): void;
            /**
                * Get the extension locale for a supported locale, or null.
                * @param {string} locale a locale code.
                * @returns {?string} a locale supported by the extension.
                */
            _getExtensionLocaleForSupportedLocale(locale: string): string | null;
            /**
                * Get the locale code used by the speech synthesis server corresponding to
                * the current language code set for the extension.
                * @returns {string} a speech synthesis locale.
                */
            _getSpeechSynthLocale(): string;
            /**
                * Get an array of the locales supported by this extension.
                * @returns {Array} An array of locale strings.
                */
            _getSupportedLocales(): any[];
            /**
                * Check if a Scratch language code is in the list of supported languages for the
                * speech synthesis service.
                * @param {string} languageCode the language code to check.
                * @returns {boolean} true if the language code is supported.
                */
            isSupportedLanguage(languageCode: string): boolean;
            /**
                * Get the menu of voices for the "set voice" block.
                * @return {array} the text and value for each menu item.
                */
            getVoiceMenu(): array;
            /**
                * Get the localized menu of languages for the "set language" block.
                * For each language:
                *   if there is a custom translated spoken language name, use that;
                *   otherwise use the translation in the languageNames menuMap;
                *   otherwise fall back to the untranslated name in LANGUAGE_INFO.
                * @return {array} the text and value for each menu item.
                */
            getLanguageMenu(): array;
            /**
                * Set the voice for speech synthesis for this sprite.
                * @param  {object} args Block arguments
                * @param {object} util Utility object provided by the runtime.
                */
            setVoice(args: object, util: object): void;
            /**
                * Set the language for speech synthesis.
                * @param  {object} args Block arguments
                */
            setLanguage(args: object): void;
            /**
                * Convert the provided text into a sound file and then play the file.
                * @param  {object} args Block arguments
                * @param {object} util Utility object provided by the runtime.
                * @return {Promise} A promise that resolves after playing the sound
                */
            speakAndWait(args: object, util: object): Promise<any>;
            runWithCCWAPI(args: any, util: any): Promise<any>;
            runWithScratchAPI(args: any, util: any): Promise<any>;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_translate' {
    export = Scratch3TranslateBlocks;
    /**
        * Class for the translate block in Scratch 3.0.
        * @constructor
        */
    class Scratch3TranslateBlocks {
            /**
                * The key to load & store a target's translate state.
                * @return {string} The key.
                */
            static get STATE_KEY(): string;
            constructor(runtime: any);
            thirdPartApiKey: string;
            host: any;
            isCCWService: boolean | undefined;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            _getXiguaSupportedLanguages(code: any): {[key:string]:string};
            /**
                * Get the human readable language value for the reporter block.
                * @return {string} the language name of the project viewer.
                */
            getViewerLanguage(): string;
            /**
                * Get the viewer's language code.
                * @return {string} the language code.
                */
            getViewerLanguageCode(): string;
            /**
                * Get a language code from a block argument. The arg can be a language code
                * or a language name, written in any language.
                * @param  {object} arg A block argument.
                * @return {string} A language code.
                */
            getLanguageCodeFromArg(arg: object): string;
            /**
                * Translates the text in the translate block to the language specified in the menu.
                * @param {object} args - the block arguments.
                * @return {Promise} - a promise that resolves after the response from the translate server.
                */
            getTranslate(args: object): Promise<any>;
            runWithCCWAPI(args: any, lang: any): Promise<any>;
            runWithScratchAPI(args: any, lang: any): Promise<any>;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_video_sensing' {
    export = Scratch3VideoSensingBlocks;
    /**
        * Class for the motion-related blocks in Scratch 3.0
        * @param {Runtime} runtime - the runtime instantiating this block package.
        * @constructor
        */
    class Scratch3VideoSensingBlocks {
            /**
                * After analyzing a frame the amount of milliseconds until another frame
                * is analyzed.
                * @type {number}
                */
            static get INTERVAL(): number;
            /**
                * Dimensions the video stream is analyzed at after its rendered to the
                * sample canvas.
                * @type {Array.<number>}
                */
            static get DIMENSIONS(): Array<number>;
            /**
                * The key to load & store a target's motion-related state.
                * @type {string}
                */
            static get STATE_KEY(): string;
            /**
                * The default motion-related state, to be used when a target has no existing motion state.
                * @type {MotionState}
                */
            static get DEFAULT_MOTION_STATE(): MotionState;
            static get SensingAttribute(): {
                    /** The amount of motion. */
                    MOTION: string;
                    /** The direction of the motion. */
                    DIRECTION: string;
            };
            static get SensingSubject(): {
                    /** The sensor traits of the whole stage. */
                    STAGE: string;
                    /** The senosr traits of the area overlapped by this sprite. */
                    SPRITE: string;
            };
            /**
                * States the video sensing activity can be set to.
                * @readonly
                * @enum {string}
                */
            static readonly get VideoState(): {
                    /** Video turned off. */
                    OFF: string;
                    /** Video turned on with default y axis mirroring. */
                    ON: string;
                    /** Video turned on without default y axis mirroring. */
                    ON_FLIPPED: string;
            };
            constructor(runtime: any);
            /**
                * The runtime instantiating this block package.
                * @type {Runtime}
                */
            runtime: Runtime;
            /**
                * The motion detection algoritm used to power the motion amount and
                * direction values.
                * @type {VideoMotion}
                */
            detect: VideoMotion;
            /**
                * The last millisecond epoch timestamp that the video stream was
                * analyzed.
                * @type {number}
                */
            _lastUpdate: number;
            /**
                * A flag to determine if this extension has been installed in a project.
                * It is set to false the first time getInfo is run.
                * @type {boolean}
                */
            firstInstall: boolean;
            set globalVideoTransparency(transparency: number);
            /**
                * The transparency setting of the video preview stored in a value
                * accessible by any object connected to the virtual machine.
                * @type {number}
                */
            get globalVideoTransparency(): number;
            set globalVideoState(state: string);
            /**
                * The video state of the video preview stored in a value accessible by any
                * object connected to the virtual machine.
                * @type {string}
                */
            get globalVideoState(): string;
            /**
                * Get the latest values for video transparency and state,
                * and set the video device to use them.
                */
            updateVideoDisplay(): void;
            /**
                * Reset the extension's data motion detection data. This will clear out
                * for example old frames, so the first analyzed frame will not be compared
                * against a frame from before reset was called.
                */
            reset(): void;
            _loopInterval: NodeJS.Timeout | undefined;
            /**
                * Stop the video sampling loop. Only used for testing.
                */
            _stopLoop(): void;
            /**
                * An array of choices of whether a reporter should return the frame's
                * motion amount or direction.
                * @type {object[]}
                * @param {string} name - the translatable name to display in sensor
                *   attribute menu
                * @param {string} value - the serializable value of the attribute
                */
            get ATTRIBUTE_INFO(): object[];
            /**
                * An array of info about the subject choices.
                * @type {object[]}
                * @param {string} name - the translatable name to display in the subject menu
                * @param {string} value - the serializable value of the subject
                */
            get SUBJECT_INFO(): object[];
            /**
                * An array of info on video state options for the "turn video [STATE]" block.
                * @type {object[]}
                * @param {string} name - the translatable name to display in the video state menu
                * @param {string} value - the serializable value stored in the block
                */
            get VIDEO_STATE_INFO(): object[];
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            /**
                * Analyze a part of the frame that a target overlaps.
                * @param {Target} target - a target to determine where to analyze
                * @returns {MotionState} the motion state for the given target
                */
            _analyzeLocalMotion(target: Target): MotionState;
            /**
                * A scratch reporter block handle that analyzes the last two frames and
                * depending on the arguments, returns the motion or direction for the
                * whole stage or just the target sprite.
                * @param {object} args - the block arguments
                * @param {BlockUtility} util - the block utility
                * @returns {number} the motion amount or direction of the stage or sprite
                */
            videoOn(args: object, util: BlockUtility): number;
            /**
                * A scratch hat block edge handle that analyzes the last two frames where
                * the target sprite overlaps and if it has more motion than the given
                * reference value.
                * @param {object} args - the block arguments
                * @param {BlockUtility} util - the block utility
                * @returns {boolean} true if the sprite overlaps more motion than the
                *   reference
                */
            whenMotionGreaterThan(args: object, util: BlockUtility): boolean;
            /**
                * A scratch command block handle that configures the video state from
                * passed arguments.
                * @param {object} args - the block arguments
                * @param {VideoState} args.VIDEO_STATE - the video state to set the device to
                */
            videoToggle(args: {
                    VIDEO_STATE: VideoState;
            }): void;
            /**
                * A scratch command block handle that configures the video preview's
                * transparency from passed arguments.
                * @param {object} args - the block arguments
                * @param {number} args.TRANSPARENCY - the transparency to set the video
                *   preview to
                */
            setVideoTransparency(args: {
                    TRANSPARENCY: number;
            }): void;
    }
    import Runtime = require("scratch-vm-dts/engine/runtime");
    import VideoMotion = require("scratch-vm-dts/extensions/scratch3_video_sensing/library");
    /**
        * States the video sensing activity can be set to.
        */
    type VideoState = string;
    namespace VideoState {
            let OFF: string;
            let ON: string;
            let ON_FLIPPED: string;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_ev3' {
    export = Scratch3Ev3Blocks;
    class Scratch3Ev3Blocks {
            /**
                * The ID of the extension.
                * @return {string} the id
                */
            static get EXTENSION_ID(): string;
            /**
                * Creates a new instance of the EV3 extension.
                * @param  {object} runtime VM runtime
                * @constructor
                */
            constructor(runtime: object);
            /**
                * The Scratch 3.0 runtime.
                * @type {Runtime}
                */
            runtime: Runtime;
            _peripheral: EV3;
            _playNoteForPicker(note: any, category: any): void;
            /**
                * Define the EV3 extension.
                * @return {object} Extension description.
                */
            getInfo(): object;
            motorTurnClockwise(args: any): Promise<any>;
            motorTurnCounterClockwise(args: any): Promise<any>;
            motorSetPower(args: any): void;
            getMotorPosition(args: any): number | undefined;
            whenButtonPressed(args: any): boolean | undefined;
            whenDistanceLessThan(args: any): boolean;
            whenBrightnessLessThan(args: any): boolean;
            buttonPressed(args: any): boolean | undefined;
            getDistance(): any;
            getBrightness(): any;
            beep(args: any): Promise<any> | undefined;
    }
    class EV3 {
            constructor(runtime: any, extensionId: any);
            /**
                * The id of the extension this peripheral belongs to.
                */
            _extensionId: any;
            /**
                * Reset all the state and timeout/interval ids.
                */
            reset(): void;
            get distance(): any;
            get brightness(): any;
            /**
                * Access a particular motor on this peripheral.
                * @param {int} index - the zero-based index of the desired motor.
                * @return {EV3Motor} - the EV3Motor instance, if any, at that index.
                */
            motor(index: int): EV3Motor;
            isButtonPressed(port: any): boolean;
            beep(freq: any, time: any): void;
            stopAll(): void;
            stopSound(): void;
            stopAllMotors(): void;
            /**
                * Called by the runtime when user wants to scan for an EV3 peripheral.
                */
            scan(): void;
            /**
                * Called by the runtime when user wants to connect to a certain EV3 peripheral.
                * @param {number} id - the id of the peripheral to connect to.
                */
            connect(id: number): void;
            /**
                * Called by the runtime when user wants to disconnect from the EV3 peripheral.
                */
            disconnect(): void;
            /**
                * Called by the runtime to detect whether the EV3 peripheral is connected.
                * @return {boolean} - the connected state.
                */
            isConnected(): boolean;
            /**
                * Send a message to the peripheral BT socket.
                * @param {Uint8Array} message - the message to send.
                * @param {boolean} [useLimiter=true] - if true, use the rate limiter
                * @return {Promise} - a promise result of the send operation.
                */
            send(message: Uint8Array, useLimiter?: boolean): Promise<any>;
            /**
                * Genrates direct commands that are sent to the EV3 as a single or compounded byte arrays.
                * See 'EV3 Communication Developer Kit', section 4, page 24 at
                * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
                *
                * Direct commands are one of two types:
                * DIRECT_COMMAND_NO_REPLY = a direct command where no reply is expected
                * DIRECT_COMMAND_REPLY = a direct command where a reply is expected, and the
                * number and length of returned values needs to be specified.
                *
                * The direct command byte array sent takes the following format:
                * Byte 0 - 1: Command size, Little Endian. Command size not including these 2 bytes
                * Byte 2 - 3: Message counter, Little Endian. Forth running counter
                * Byte 4:     Command type. Either DIRECT_COMMAND_REPLY or DIRECT_COMMAND_NO_REPLY
                * Byte 5 - 6: Reservation (allocation) of global and local variables using a compressed format
                *             (globals reserved in byte 5 and the 2 lsb of byte 6, locals reserved in the upper
                *             6 bits of byte 6) – see documentation for more details.
                * Byte 7 - n: Byte codes as a single command or compound commands (I.e. more commands composed
                *             as a small program)
                *
                * @param {number} type - the direct command type.
                * @param {string} byteCommands - a compound array of EV3 Opcode + arguments.
                * @param {number} allocation - the allocation of global and local vars needed for replies.
                * @return {array} - generated complete command byte array, with header and compounded commands.
                */
            generateCommand(type: number, byteCommands: string, allocation?: number): array;
            _updateDevices: boolean | undefined;
    }
    /**
        * Manage power, direction, and timers for one EV3 motor.
        */
    class EV3Motor {
            /**
                * Construct a EV3 Motor instance, which could be of type 'largeMotor' or
                * 'mediumMotor'.
                *
                * @param {EV3} parent - the EV3 peripheral which owns this motor.
                * @param {int} index - the zero-based index of this motor on its parent peripheral.
                * @param {string} type - the type of motor (i.e. 'largeMotor' or 'mediumMotor').
                */
            constructor(parent: EV3, index: int, type: string);
            /**
                * @param {string} value - this motor's new type: 'largeMotor' or 'mediumMotor'
                */
            set type(value: string);
            /**
                * @return {string} - this motor's type: 'largeMotor' or 'mediumMotor'
                */
            get type(): string;
            /**
                * @param {int} value - this motor's new direction: 1 for "clockwise" or -1 for "counterclockwise"
                */
            set direction(value: int);
            /**
                * @return {int} - this motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
                */
            get direction(): int;
            /**
                * @param {int} value - this motor's new power level, in the range [0,100].
                */
            set power(value: int);
            /**
                * @return {int} - this motor's current power level, in the range [0,100].
                */
            get power(): int;
            /**
                * @param {int} array - this motor's new position, in the range [0,360].
                */
            set position(array: int);
            /**
                * @return {int} - this motor's current position, in the range [-inf,inf].
                */
            get position(): int;
            /**
                * Turn this motor on for a specific duration.
                * Found in the 'EV3 Firmware Developer Kit', page 56, at
                * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
                *
                * Opcode arguments:
                * (Data8) LAYER – Specify chain layer number [0 - 3]
                * (Data8) NOS – Output bit field [0x00 – 0x0F]
                * (Data8) SPEED – Power level, [-100 – 100]
                * (Data32) STEP1 – Time in milliseconds for ramp up
                * (Data32) STEP2 – Time in milliseconds for continues run
                * (Data32) STEP3 – Time in milliseconds for ramp down
                * (Data8) BRAKE - Specify break level [0: Float, 1: Break]
                *
                * @param {number} milliseconds - run the motor for this long.
                */
            turnOnFor(milliseconds: number): void;
            /**
                * Set the motor to coast after a specified amount of time.
                * @param {number} time - the time in milliseconds.
                */
            coastAfter(time: number): void;
            /**
                * Set the motor to coast.
                */
            coast(): void;
            /**
                * Generate motor run values for a given input.
                * @param  {number} run - run input.
                * @return {array} - run values as a byte array.
                */
            _runValues(run: number): array;
            /**
                * Return a port value for the EV3 that is in the format for 'output bit field'
                * as 1/2/4/8, generally needed for motor ports, instead of the typical 0/1/2/3.
                * The documentation in the 'EV3 Firmware Developer Kit' for motor port arguments
                * is sometimes mistaken, but we believe motor ports are mostly addressed this way.
                * @param {number} port - the port number to convert to an 'output bit field'.
                * @return {number} - the converted port number.
                */
            _portMask(port: number): number;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_makeymakey' {
    export = Scratch3MakeyMakeyBlocks;
    /**
        * Class for the makey makey blocks in Scratch 3.0
        * @constructor
        */
    class Scratch3MakeyMakeyBlocks {
            constructor(runtime: any);
            /**
                * The runtime instantiating this block package.
                * @type {Runtime}
                */
            runtime: Runtime;
            /**
                * A toggle that alternates true and false each frame, so that an
                * edge-triggered hat can trigger on every other frame.
                * @type {boolean}
                */
            frameToggle: boolean;
            keyPressed(key: any): void;
            /**
                * Clear the key press buffer.
                */
            _clearkeyPressBuffer(): void;
            sequences: {};
            keyPressBuffer: any[];
            get KEY_TEXT_SHORT(): {
                    SPACE: string;
                    LEFT: string;
                    UP: string;
                    RIGHT: string;
                    DOWN: string;
            };
            get DEFAULT_SEQUENCES(): string[];
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            buildSequenceMenu(sequencesArray: any): any;
            getMenuItemForSequenceString(sequenceString: any): {
                    text: any;
                    value: any;
            };
            whenMakeyKeyPressed(args: any, util: any): any;
            addSequence(sequenceString: any, sequenceArray: any): void;
            whenCodePressed(args: any): any;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_boost' {
    export = Scratch3BoostBlocks;
    /**
        * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.
        */
    class Scratch3BoostBlocks {
            /**
                * @return {string} - the ID of this extension.
                */
            static get EXTENSION_ID(): string;
            /**
                * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
                */
            static get TILT_THRESHOLD(): number;
            /**
                * Construct a set of Boost blocks.
                * @param {Runtime} runtime - the Scratch 3.0 runtime.
                */
            constructor(runtime: Runtime);
            /**
                * The Scratch 3.0 runtime.
                * @type {Runtime}
                */
            runtime: Runtime;
            _peripheral: Boost;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            /**
                * Turn specified motor(s) on for a specified duration.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to activate.
                * @property {int} DURATION - the amount of time to run the motors.
                * @return {Promise} - a promise which will resolve at the end of the duration.
                */
            motorOnFor(args: object): Promise<any>;
            /**
                * Turn specified motor(s) on for a specified rotation in full rotations.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to activate.
                * @property {int} ROTATION - the amount of full rotations to turn the motors.
                * @return {Promise} - a promise which will resolve at the end of the duration.
                */
            motorOnForRotation(args: object): Promise<any>;
            /**
                * Turn specified motor(s) on indefinitely.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to activate.
                * @return {Promise} - a Promise that resolves after some delay.
                */
            motorOn(args: object): Promise<any>;
            /**
                * Turn specified motor(s) off.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
                * @return {Promise} - a Promise that resolves after some delay.
                */
            motorOff(args: object): Promise<any>;
            /**
                * Set the power level of the specified motor(s).
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
                * @property {int} POWER - the new power level for the motor(s).
                * @return {Promise} - returns a promise to make sure the block yields.
                */
            setMotorPower(args: object): Promise<any>;
            /**
                * Set the direction of rotation for specified motor(s).
                * If the direction is 'reverse' the motor(s) will be reversed individually.
                * @param {object} args - the block's arguments.
                * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
                * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
                * @return {Promise} - returns a promise to make sure the block yields.
                */
            setMotorDirection(args: object): Promise<any>;
            /**
                * @param {object} args - the block's arguments.
                * @return {number} - returns the motor's position.
                */
            getMotorPosition(args: object): number;
            /**
                * Test whether the tilt sensor is currently tilted.
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
                * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
                */
            whenTilted(args: object): boolean;
            /**
                * Test whether the tilt sensor is currently tilted.
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
                * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
                */
            isTilted(args: object): boolean;
            /**
                * @param {object} args - the block's arguments.
                * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
                * @return {number} - the tilt sensor's angle in the specified direction.
                * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
                */
            getTiltAngle(args: object): number;
            /**
                * Edge-triggering hat function, for when the vision sensor is detecting
                * a certain color.
                * @param {object} args - the block's arguments.
                * @return {boolean} - true when the color sensor senses the specified color.
                */
            whenColor(args: object): boolean;
            /**
                * A boolean reporter function, for whether the vision sensor is detecting
                * a certain color.
                * @param {object} args - the block's arguments.
                * @return {boolean} - true when the color sensor senses the specified color.
                */
            seeingColor(args: object): boolean;
            /**
                * Set the LED's hue.
                * @param {object} args - the block's arguments.
                * @property {number} HUE - the hue to set, in the range [0,100].
                * @return {Promise} - a Promise that resolves after some delay.
                */
            setLightHue(args: object): Promise<any>;
    }
    /**
        * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.
        */
    class Boost {
            constructor(runtime: any, extensionId: any);
            /**
                * The id of the extension this peripheral belongs to.
                */
            _extensionId: any;
            /**
                * Reset all the state and timeout/interval ids.
                */
            reset(): void;
            /**
                * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
                */
            get tiltX(): number;
            /**
                * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
                */
            get tiltY(): number;
            /**
                * @return {number} - the latest color value received from the vision sensor.
                */
            get color(): number;
            /**
                * @return {number} - the previous color value received from the vision sensor.
                */
            get previousColor(): number;
            /**
                * Look up the color id for an index received from the vision sensor.
                * @param {number} index - the color index to look up.
                * @return {BoostColor} the color id for this index.
                */
            boostColorForIndex(index: number): BoostColor;
            /**
                * Access a particular motor on this peripheral.
                * @param {int} index - the index of the desired motor.
                * @return {BoostMotor} - the BoostMotor instance, if any, at that index.
                */
            motor(index: int): BoostMotor;
            /**
                * Stop all the motors that are currently running.
                */
            stopAllMotors(): void;
            /**
                * Set the Boost peripheral's LED to a specific color.
                * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
                * @return {Promise} - a promise of the completion of the set led send operation.
                */
            setLED(inputRGB: int): Promise<any>;
            /**
                * Sets the input mode of the LED to RGB.
                * @return {Promise} - a promise returned by the send operation.
                */
            setLEDMode(): Promise<any>;
            /**
                * Stop the motors on the Boost peripheral.
                */
            stopAll(): void;
            /**
                * Called by the runtime when user wants to scan for a Boost peripheral.
                */
            scan(): void;
            /**
                * Called by the runtime when user wants to connect to a certain Boost peripheral.
                * @param {number} id - the id of the peripheral to connect to.
                */
            connect(id: number): void;
            /**
                * Disconnects from the current BLE socket and resets state.
                */
            disconnect(): void;
            /**
                * Called by the runtime to detect whether the Boost peripheral is connected.
                * @return {boolean} - the connected state.
                */
            isConnected(): boolean;
            /**
                * Write a message to the Boost peripheral BLE socket.
                * @param {number} uuid - the UUID of the characteristic to write to
                * @param {Array} message - the message to write.
                * @param {boolean} [useLimiter=true] - if true, use the rate limiter
                * @return {Promise} - a promise result of the write operation
                */
            send(uuid: number, message: any[], useLimiter?: boolean): Promise<any>;
            /**
                * Generate a Boost 'Output Command' in the byte array format
                * (COMMON HEADER, PORT ID, EXECUTION BYTE, SUBCOMMAND ID, PAYLOAD).
                *
                * Payload is accepted as an array since these vary across different subcommands.
                *
                * @param  {number} portID - the port (Connect ID) to send a command to.
                * @param  {number} execution - Byte containing startup/completion information
                * @param  {number} subCommand - the id of the subcommand byte.
                * @param  {array}  payload    - the list of bytes to send as subcommand payload
                * @return {array}            - a generated output command.
                */
            generateOutputCommand(portID: number, execution: number, subCommand: number, payload: array): array;
            /**
                * Generate a Boost 'Input Command' in the byte array format
                * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
                * UNIT, NOTIFICATIONS ENABLED).
                *
                * This sends a command to the Boost that sets that input format
                * of the specified inputs and sets value change notifications.
                *
                * @param  {number}  portID           - the port (Connect ID) to send a command to.
                * @param  {number}  mode                - the mode of the input sensor.
                * @param  {number}  delta               - the delta change needed to trigger notification.
                * @param  {boolean} enableNotifications - whether to enable notifications.
                * @return {array}                       - a generated input command.
                */
            generateInputCommand(portID: number, mode: number, delta: number, enableNotifications: boolean): array;
    }
    /**
        * Ids for each color sensor value used by the extension.
        */
    type BoostColor = string;
    namespace BoostColor {
            let ANY: string;
            let NONE: string;
            let RED: string;
            let BLUE: string;
            let GREEN: string;
            let YELLOW: string;
            let WHITE: string;
            let BLACK: string;
    }
    /**
        * Manage power, direction, position, and timers for one Boost motor.
        */
    class BoostMotor {
            /**
                * Construct a Boost Motor instance.
                * @param {Boost} parent - the Boost peripheral which owns this motor.
                * @param {int} index - the zero-based index of this motor on its parent peripheral.
                */
            constructor(parent: Boost, index: int);
            /**
                * Turn this motor off.
                * @param {boolean} [useLimiter=true] - if true, use the rate limiter
                */
            turnOff(useLimiter?: boolean): void;
            /**
                * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
                */
            set direction(value: int);
            /**
                * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
                */
            get direction(): int;
            /**
                * @param {int} value - this motor's new power level, in the range [10,100].
                */
            set power(value: int);
            /**
                * @return {int} - this motor's current power level, in the range [0,100].
                */
            get power(): int;
            /**
                * @param {int} value - set this motor's current position.
                */
            set position(value: int);
            /**
                * @return {int} - this motor's current position, in the range of [-MIN_INT32,MAX_INT32]
                */
            get position(): int;
            /**
                * @param {BoostMotorState} value - set this motor's state.
                */
            set status(value: {
                    OFF: number;
                    ON_FOREVER: number;
                    ON_FOR_TIME: number;
                    ON_FOR_ROTATION: number;
            });
            /**
                * @return {BoostMotorState} - the motor's current state.
                */
            get status(): {
                    OFF: number;
                    ON_FOREVER: number;
                    ON_FOR_TIME: number;
                    ON_FOR_ROTATION: number;
            };
            /**
                * @return {number} - time, in milliseconds, of when the pending duration timeout began.
                */
            get pendingDurationTimeoutStartTime(): number;
            /**
                * @return {number} - delay, in milliseconds, of the pending duration timeout.
                */
            get pendingDurationTimeoutDelay(): number;
            /**
                * @return {number} - target position, in degrees, of the pending rotation.
                */
            get pendingRotationDestination(): number;
            /**
                * @param {function} func - function to resolve pending rotation Promise
                */
            set pendingRotationPromise(func: Function);
            /**
                * @return {Promise} - the Promise function for the pending rotation.
                */
            get pendingRotationPromise(): Promise<any>;
            /**
                * Turn this motor on indefinitely
                */
            turnOnForever(): void;
            /**
                * Turn this motor on for a specific duration.
                * @param {number} milliseconds - run the motor for this long.
                */
            turnOnFor(milliseconds: number): void;
            /**
                * Turn this motor on for a specific rotation in degrees.
                * @param {number} degrees - run the motor for this amount of degrees.
                * @param {number} direction - rotate in this direction
                */
            turnOnForDegrees(degrees: number, direction: number): void;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_gdx_for' {
    export = Scratch3GdxForBlocks;
    /**
        * Scratch 3.0 blocks to interact with a GDX-FOR peripheral.
        */
    class Scratch3GdxForBlocks {
            /**
                * @return {string} - the name of this extension.
                */
            static get EXTENSION_NAME(): string;
            /**
                * @return {string} - the ID of this extension.
                */
            static get EXTENSION_ID(): string;
            /**
                * Construct a set of GDX-FOR blocks.
                * @param {Runtime} runtime - the Scratch 3.0 runtime.
                */
            constructor(runtime: Runtime);
            get AXIS_MENU(): {
                    text: string;
                    value: string;
            }[];
            get TILT_MENU(): {
                    text: string;
                    value: string;
            }[];
            get TILT_MENU_ANY(): {
                    text: string;
                    value: string;
            }[];
            get PUSH_PULL_MENU(): {
                    text: string;
                    value: string;
            }[];
            get GESTURE_MENU(): {
                    text: string;
                    value: string;
            }[];
            /**
                * The Scratch 3.0 runtime.
                * @type {Runtime}
                */
            runtime: Runtime;
            _peripheral: GdxFor;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            whenForcePushedOrPulled(args: any): boolean;
            getForce(): number;
            whenGesture(args: any): boolean;
            _isFacing(direction: any): boolean;
            _facingUp: boolean | undefined;
            _facingDown: boolean | undefined;
            whenTilted(args: any): boolean;
            isTilted(args: any): boolean;
            getTilt(args: any): number | undefined;
            _isTilted(direction: any): boolean;
            _getTiltAngle(direction: any): number | undefined;
            getSpinSpeed(args: any): number | undefined;
            getAcceleration(args: any): number | undefined;
            /**
                * @param {number} x - x axis vector
                * @param {number} y - y axis vector
                * @param {number} z - z axis vector
                * @return {number} - the magnitude of a three dimension vector.
                */
            magnitude(x: number, y: number, z: number): number;
            accelMagnitude(): number;
            gestureMagnitude(): number;
            spinMagnitude(): number;
            isFreeFalling(): boolean;
    }
    /**
        * Manage communication with a GDX-FOR peripheral over a Scratch Link client socket.
        */
    class GdxFor {
            /**
                * Construct a GDX-FOR communication object.
                * @param {Runtime} runtime - the Scratch 3.0 runtime
                * @param {string} extensionId - the id of the extension
                */
            constructor(runtime: Runtime, extensionId: string);
            /**
                * The id of the extension this peripheral belongs to.
                */
            _extensionId: string;
            /**
                * Reset all the state and timeout/interval ids.
                */
            reset(): void;
            /**
                * Called by the runtime when user wants to scan for a peripheral.
                */
            scan(): void;
            /**
                * Called by the runtime when user wants to connect to a certain peripheral.
                * @param {number} id - the id of the peripheral to connect to.
                */
            connect(id: number): void;
            /**
                * Called by the runtime when a user exits the connection popup.
                * Disconnect from the GDX FOR.
                */
            disconnect(): void;
            /**
                * Return true if connected to the goforce device.
                * @return {boolean} - whether the goforce is connected.
                */
            isConnected(): boolean;
            _spinSpeedFromGyro(val: any): any;
            getForce(): number;
            getTiltFrontBack(back?: boolean): number;
            getTiltLeftRight(right?: boolean): number;
            getAccelerationX(): number;
            getAccelerationY(): number;
            getAccelerationZ(): number;
            getSpinSpeedX(): number;
            getSpinSpeedY(): number;
            getSpinSpeedZ(): number;
    }
}

declare module 'scratch-vm-dts/extensions/tw' {
    export = TurboWarpBlocks;
    /**
        * Class for TurboWarp blocks
        * @constructor
        */
    class TurboWarpBlocks {
            constructor(runtime: any);
            /**
                * The runtime instantiating this block package.
                * @type {Runtime}
                */
            runtime: Runtime;
            /**
                * @returns {object} metadata for this extension and its blocks.
                */
            getInfo(): object;
            getLastKeyPressed(args: any, util: any): any;
            getButtonIsDown(args: any, util: any): any;
    }
}

declare module 'scratch-vm-dts/extension-support/tw-security-manager' {
    export = SecurityManager;
    /**
        * Responsible for determining various policies related to custom extension security.
        * The default implementation prevents automatic extension loading, but grants any
        * loaded extensions the maximum possible capabilities so as to retain compatibility
        * with a vanilla scratch-vm. You may override properties of an instance of this class
        * to customize the security policies as you see fit, for example:
        * ```js
        * vm.securityManager.getSandboxMode = (url) => {
        *   if (url.startsWith("https://example.com/")) {
        *     return "unsandboxed";
        *   }
        *   return "iframe";
        * };
        * vm.securityManager.canAutomaticallyLoadExtension = (url) => {
        *   return confirm("Automatically load extension: " + url);
        * };
        * vm.securityManager.canFetch = (url) => {
        *   return url.startsWith('https://turbowarp.org/');
        * };
        * vm.securityManager.canOpenWindow = (url) => {
        *   return url.startsWith('https://turbowarp.org/');
        * };
        * vm.securityManager.canRedirect = (url) => {
        *   return url.startsWith('https://turbowarp.org/');
        * };
        * ```
        */
    class SecurityManager {
            /**
                * Determine the typeof sandbox to use for a certain custom extension.
                * @param {string} extensionURL The URL of the custom extension.
                * @returns {'worker'|'iframe'|'unsandboxed'|Promise<'worker'|'iframe'|'unsandboxed'>}
                */
            getSandboxMode(extensionURL: string): "worker" | "iframe" | "unsandboxed" | Promise<"worker" | "iframe" | "unsandboxed">;
            /**
                * Determine whether a custom extension that was stored inside a project may be
                * loaded. You could, for example, ask the user to confirm loading an extension
                * before resolving.
                * @param {string} extensionURL The URL of the custom extension.
                * @returns {Promise<boolean>|boolean}
                */
            canLoadExtensionFromProject(extensionURL: string): Promise<boolean> | boolean;
            /**
                * Allows last-minute changing the real URL of the extension that gets loaded.
                * @param {*} extensionURL The URL requested to be loaded.
                * @returns {Promise<string>|string} The URL to actually load.
                */
            rewriteExtensionURL(extensionURL: any): Promise<string> | string;
            /**
                * Determine whether an extension is allowed to fetch a remote resource URL.
                * This only applies to unsandboxed extensions that use the appropriate Scratch.* APIs.
                * Sandboxed extensions ignore this entirely as there is no way to force them to use our APIs.
                * data: and blob: URLs are always allowed (this method is never called).
                * @param {string} resourceURL
                * @returns {Promise<boolean>|boolean}
                */
            canFetch(resourceURL: string): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to open a new window or tab to a given URL.
                * This only applies to unsandboxed extensions. Sandboxed extensions are unable to open windows.
                * javascript: URLs are always rejected (this method is never called).
                * @param {string} websiteURL
                * @returns {Promise<boolean>|boolean}
                */
            canOpenWindow(websiteURL: string): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to redirect the current tab to a given URL.
                * This only applies to unsandboxed extensions. Sandboxed extensions are unable to redirect the parent
                * window, but are free to redirect their own sandboxed window.
                * javascript: URLs are always rejected (this method is never called).
                * @param {string} websiteURL
                * @returns {Promise<boolean>|boolean}
                */
            canRedirect(websiteURL: string): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to record audio from the user's microphone.
                * This could include raw audio data or a transcriptions.
                * Note that, even if this returns true, success is not guaranteed.
                * @returns {Promise<boolean>|boolean}
                */
            canRecordAudio(): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to record video from the user's camera.
                * Note that, even if this returns true, success is not guaranteed.
                * @returns {Promise<boolean>|boolean}
                */
            canRecordVideo(): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to read values from the user's clipboard
                * without user interaction.
                * Note that, even if this returns true, success is not guaranteed.
                * @returns {Promise<boolean>|boolean}
                */
            canReadClipboard(): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to show notifications.
                * Note that, even if this returns true, success is not guaranteed.
                * @returns {Promise<boolean>|boolean}
                */
            canNotify(): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to find the user's precise location using GPS
                * and other techniques. Note that, even if this returns true, success is not guaranteed.
                * @returns {Promise<boolean>|boolean}
                */
            canGeolocate(): Promise<boolean> | boolean;
            /**
                * Determine whether an extension is allowed to embed content from a given URL.
                * @param {string} documentURL The URL of the embed.
                * @returns {Promise<boolean>|boolean}
                */
            canEmbed(documentURL: string): Promise<boolean> | boolean;
    }
}

declare module 'scratch-vm-dts/extension-support/block-type' {
    export = BlockType;
    /**
      * Types of block
      */
    type BlockType = string;
    namespace BlockType {
        let BOOLEAN: string;
        let BUTTON: string;
        let LABEL: string;
        let COMMAND: string;
        let CONDITIONAL: string;
        let EVENT: string;
        let HAT: string;
        let LOOP: string;
        let REPORTER: string;
        let XML: string;
    }
}

declare module 'scratch-vm-dts/extensions/scratch3_video_sensing/library' {
    export = VideoMotion;
    /**
        * Store the necessary image pixel data to compares frames of a video and
        * detect an amount and direction of motion in the full sample or in a
        * specified area.
        * @constructor
        */
    class VideoMotion {
            /**
                * The number of frames that have been added from a source.
                * @type {number}
                */
            frameNumber: number;
            /**
                * The frameNumber last analyzed.
                * @type {number}
                */
            lastAnalyzedFrame: number;
            /**
                * The amount of motion detected in the current frame.
                * @type {number}
                */
            motionAmount: number;
            /**
                * The direction the motion detected in the frame is general moving in.
                * @type {number}
                */
            motionDirection: number;
            /**
                * A copy of the current frame's pixel values. A index of the array is
                * represented in RGBA. The lowest byte is red. The next is green. The
                * next is blue. And the last is the alpha value of that pixel.
                * @type {Uint32Array}
                */
            curr: Uint32Array;
            /**
                * A copy of the last frame's pixel values.
                * @type {Uint32Array}
                */
            prev: Uint32Array;
            /**
                * A buffer for holding one component of a pixel's full value twice.
                * One for the current value. And one for the last value.
                * @type {number}
                */
            _arrays: number;
            /**
                * A clamped uint8 view of _arrays. One component of each index of the
                * curr member is copied into this array.
                * @type {number}
                */
            _curr: number;
            /**
                * A clamped uint8 view of _arrays. One component of each index of the
                * prev member is copied into this array.
                * @type {number}
                */
            _prev: number;
            /**
                * Reset internal state so future frame analysis does not consider values
                * from before this method was called.
                */
            reset(): void;
            /**
                * Add a frame to be next analyzed. The passed array represent a pixel with
                * each index in the RGBA format.
                * @param {Uint32Array} source - a source frame of pixels to copy
                */
            addFrame(source: Uint32Array): void;
            /**
                * Analyze the current frame against the previous frame determining the
                * amount of motion and direction of the motion.
                */
            analyzeFrame(): void;
            /**
                * Build motion amount and direction values based on stored current and
                * previous frame that overlaps a given drawable.
                * @param {Drawable} drawable - touchable and bounded drawable to build motion for
                * @param {MotionState} state - state to store built values to
                */
            getLocalMotion(drawable: Drawable, state: MotionState): void;
    }
}

